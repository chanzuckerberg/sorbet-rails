require('parlour')
require('sorbet-rails/model_utils')
require('sorbet-rails/model_plugins/active_record_enum')
class ModelRbiFormatterRefactor
  include SorbetRails::ModelUtils

  attr_reader :model_class
  attr_reader :available_classes

  def initialize(model_class, available_classes)
    @model_class = model_class
    @available_classes = available_classes
    @columns_hash = model_class.table_exists? ? model_class.columns_hash : {}
    begin
      # Load all dynamic instance methods of this model by instantiating a fake model
      @model_class.new unless @model_class.abstract_class?
    rescue StandardError
      puts "Note: Unable to create new instance of #{model_class.name}"
    end
  end

  def generate_rbi
    byebug
    # TODO: make this customizable
    plugins = [
      SorbetRails::ModelPlugins::ActiveRecordEnum,
    ]

    # Collect the instances of each plugin into an array
    plugin_instances = plugins.map do |plugin_klass|
      plugin_klass.new(model_class, available_classes)
    end

    generator = Parlour::RbiGenerator.new(break_params: 3)
    generate_base_rbi(generator.root)
    Parlour::Plugin.run_plugins(plugin_instances, generator)

    Parlour::ConflictResolver.new.resolve_conflicts(generator.root) do |msg, candidates|
      puts "Conflict: #{msg}. Remove the conflicted method signatures"
      nil
    end

    <<~MESSAGE
      # This is an autogenerated file for dynamic methods in #{@model_class.name}
      # Please rerun rake rails_rbi:models[#{@model_class.name}] to regenerate.

      #{generator.rbi}
    MESSAGE
  end

  def generate_base_rbi(root)
    # This is the backbone of the model_rbi_formatter.
    # It could live in a base plugin but I consider it not replacable and better to leave here
    model_relation_rbi = root.create_class(
      name: model_relation_class_name,
      superclass: "ActiveRecord::Relation",
    )
    model_relation_rbi.create_include(name: model_relation_shared_module_name)
    model_relation_rbi.create_extend(name: "T::Generic")
    model_relation_rbi.create_constant(
      name: "Elem",
      value: "type_member(fixed: #{model_class_name})",
    )

    collection_proxy_rbi = root.create_class(
      name: model_assoc_proxy_class_name,
      superclass: "ActiveRecord::Associations::CollectionProxy",
    )
    collection_proxy_rbi.create_include(name: model_relation_shared_module_name)
    collection_proxy_rbi.create_extend(name: "T::Generic")
    collection_proxy_rbi.create_constant(
      name: "Elem",
      value: "type_member(fixed: #{model_class_name})",
    )

    model_rbi = root.create_class(name: model_class_name)
    model_rbi.create_extend(name: "T::Sig")
    model_rbi.create_extend(name: "T::Generic")
    model_rbi.create_include(name: model_relation_shared_module_name)
    collection_proxy_rbi.create_constant(
      name: "Elem",
      value: "type_member(fixed: #{model_class_name})",
    )

    # <Model>::MODEL_RELATION_SHARED_MODULE_SUFFIX is a fake module added so that
    # when a method is defined in this module, it'll be added to both the Model class
    # as a class method and to its relation as an instance method.
    #
    # We need to define the module after the other classes
    # to work around Sorbet loading order bug
    # https://sorbet-ruby.slack.com/archives/CHN2L03NH/p1556065791047300
    model_relation_shared_rbi = root.create_module(name: model_relation_shared_module_name)
    model_relation_shared_rbi.create_extend(name: "T::Sig")
  end
end