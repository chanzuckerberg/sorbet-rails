# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

class ActionDispatch::AssertionResponse
  def code(); end

  def code_and_name(); end

  def initialize(code_or_name); end

  def name(); end
  GENERIC_RESPONSE_CODES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::AssertionResponse
end

module ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  def html_document(); end
end

module ActionDispatch::Assertions::ResponseAssertions
  def assert_redirected_to(options=T.unsafe(nil), message=T.unsafe(nil)); end

  def assert_response(type, message=T.unsafe(nil)); end
  RESPONSE_PREDICATES = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Assertions::ResponseAssertions
end

module ActionDispatch::Assertions::RoutingAssertions
  def assert_generates(expected_path, options, defaults=T.unsafe(nil), extras=T.unsafe(nil), message=T.unsafe(nil)); end

  def assert_recognizes(expected_options, path, extras=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_routing(path, options, defaults=T.unsafe(nil), extras=T.unsafe(nil), message=T.unsafe(nil)); end

  def method_missing(selector, *args, &block); end

  def with_routing(); end
end

module ActionDispatch::Assertions::RoutingAssertions
end

module ActionDispatch::Assertions
  extend ::ActiveSupport::Concern
end

class ActionDispatch::Callbacks
  include ::ActiveSupport::Callbacks
  def __callbacks(); end

  def __callbacks?(); end

  def _call_callbacks(); end

  def _run_call_callbacks(&block); end

  def call(env); end

  def initialize(app); end
end

class ActionDispatch::Callbacks
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._call_callbacks(); end

  def self._call_callbacks=(value); end

  def self.after(*args, &block); end

  def self.before(*args, &block); end
end

class ActionDispatch::ContentSecurityPolicy
  def base_uri(*sources); end

  def block_all_mixed_content(enabled=T.unsafe(nil)); end

  def build(context=T.unsafe(nil), nonce=T.unsafe(nil)); end

  def child_src(*sources); end

  def connect_src(*sources); end

  def default_src(*sources); end

  def directives(); end

  def font_src(*sources); end

  def form_action(*sources); end

  def frame_ancestors(*sources); end

  def frame_src(*sources); end

  def img_src(*sources); end

  def manifest_src(*sources); end

  def media_src(*sources); end

  def object_src(*sources); end

  def plugin_types(*types); end

  def report_uri(uri); end

  def require_sri_for(*types); end

  def sandbox(*values); end

  def script_src(*sources); end

  def style_src(*sources); end

  def upgrade_insecure_requests(enabled=T.unsafe(nil)); end

  def worker_src(*sources); end
end

class ActionDispatch::ContentSecurityPolicy::Middleware
  def call(env); end

  def initialize(app); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  POLICY = ::T.let(nil, ::T.untyped)
  POLICY_REPORT_ONLY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::ContentSecurityPolicy::Middleware
end

module ActionDispatch::ContentSecurityPolicy::Request
  def content_security_policy(); end

  def content_security_policy=(policy); end

  def content_security_policy_nonce(); end

  def content_security_policy_nonce_generator(); end

  def content_security_policy_nonce_generator=(generator); end

  def content_security_policy_report_only(); end

  def content_security_policy_report_only=(value); end
  NONCE = ::T.let(nil, ::T.untyped)
  NONCE_GENERATOR = ::T.let(nil, ::T.untyped)
  POLICY = ::T.let(nil, ::T.untyped)
  POLICY_REPORT_ONLY = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::ContentSecurityPolicy::Request
end

class ActionDispatch::ContentSecurityPolicy
end

class ActionDispatch::Cookies
  def call(env); end

  def initialize(app); end
  AUTHENTICATED_ENCRYPTED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  COOKIES_DIGEST = ::T.let(nil, ::T.untyped)
  COOKIES_ROTATIONS = ::T.let(nil, ::T.untyped)
  COOKIES_SERIALIZER = ::T.let(nil, ::T.untyped)
  ENCRYPTED_COOKIE_CIPHER = ::T.let(nil, ::T.untyped)
  ENCRYPTED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  ENCRYPTED_SIGNED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  GENERATOR_KEY = ::T.let(nil, ::T.untyped)
  HTTP_HEADER = ::T.let(nil, ::T.untyped)
  MAX_COOKIE_SIZE = ::T.let(nil, ::T.untyped)
  SECRET_KEY_BASE = ::T.let(nil, ::T.untyped)
  SECRET_TOKEN = ::T.let(nil, ::T.untyped)
  SIGNED_COOKIE_DIGEST = ::T.let(nil, ::T.untyped)
  SIGNED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  USE_AUTHENTICATED_COOKIE_ENCRYPTION = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Cookies::AbstractCookieJar
  include ::ActionDispatch::Cookies::ChainedCookieJars
  def [](name); end

  def []=(name, options); end

  def initialize(parent_jar); end

  def request(); end
end

class ActionDispatch::Cookies::AbstractCookieJar
end

module ActionDispatch::Cookies::ChainedCookieJars
  def encrypted(); end

  def permanent(); end

  def signed(); end

  def signed_or_encrypted(); end
end

module ActionDispatch::Cookies::ChainedCookieJars
end

class ActionDispatch::Cookies::CookieJar
  include ::ActionDispatch::Cookies::ChainedCookieJars
  include ::Enumerable
  def [](name); end

  def []=(name, options); end

  def always_write_cookie(); end

  def always_write_cookie=(obj); end

  def clear(options=T.unsafe(nil)); end

  def commit!(); end

  def committed?(); end

  def delete(name, options=T.unsafe(nil)); end

  def deleted?(name, options=T.unsafe(nil)); end

  def each(&block); end

  def fetch(name, *args, &block); end

  def handle_options(options); end

  def has_key?(name); end

  def initialize(request); end

  def key?(name); end

  def request(); end

  def to_hash(*_); end

  def to_header(); end

  def update(other_hash); end

  def update_cookies_from_jar(); end

  def write(headers); end
  DOMAIN_REGEXP = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Cookies::CookieJar
  def self.always_write_cookie(); end

  def self.always_write_cookie=(obj); end

  def self.build(req, cookies); end
end

class ActionDispatch::Cookies::CookieOverflow
end

class ActionDispatch::Cookies::CookieOverflow
end

class ActionDispatch::Cookies::EncryptedKeyRotatingCookieJar
  include ::ActionDispatch::Cookies::SerializedCookieJars
end

class ActionDispatch::Cookies::EncryptedKeyRotatingCookieJar
end

class ActionDispatch::Cookies::JsonSerializer
end

class ActionDispatch::Cookies::JsonSerializer
  def self.dump(value); end

  def self.load(value); end
end

class ActionDispatch::Cookies::PermanentCookieJar
end

class ActionDispatch::Cookies::PermanentCookieJar
end

module ActionDispatch::Cookies::SerializedCookieJars
  def deserialize(name); end

  def digest(); end

  def needs_migration?(value); end

  def serialize(value); end

  def serializer(); end
  MARSHAL_SIGNATURE = ::T.let(nil, ::T.untyped)
end

ActionDispatch::Cookies::SerializedCookieJars::SERIALIZER = ActiveSupport::MessageEncryptor::NullSerializer

module ActionDispatch::Cookies::SerializedCookieJars
end

class ActionDispatch::Cookies::SignedKeyRotatingCookieJar
  include ::ActionDispatch::Cookies::SerializedCookieJars
end

class ActionDispatch::Cookies::SignedKeyRotatingCookieJar
end

class ActionDispatch::Cookies
end

class ActionDispatch::DebugExceptions
  def call(env); end

  def initialize(app, routes_app=T.unsafe(nil), response_format=T.unsafe(nil)); end
  RESCUES_TEMPLATE_PATH = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::DebugExceptions::DebugView
  def debug_hash(object); end

  def debug_headers(headers); end

  def debug_params(params); end

  def render(*_); end
end

class ActionDispatch::DebugExceptions::DebugView
end

class ActionDispatch::DebugExceptions
end

class ActionDispatch::DebugLocks
  def call(env); end

  def initialize(app, path=T.unsafe(nil)); end
end

class ActionDispatch::DebugLocks
end

class ActionDispatch::ExceptionWrapper
  def application_trace(); end

  def backtrace_cleaner(); end

  def exception(); end

  def file(); end

  def framework_trace(); end

  def full_trace(); end

  def initialize(backtrace_cleaner, exception); end

  def line_number(); end

  def rescue_responses(); end

  def rescue_responses=(obj); end

  def rescue_template(); end

  def rescue_templates(); end

  def rescue_templates=(obj); end

  def source_extracts(); end

  def status_code(); end

  def traces(); end
end

class ActionDispatch::ExceptionWrapper
  def self.rescue_responses(); end

  def self.rescue_responses=(obj); end

  def self.rescue_templates(); end

  def self.rescue_templates=(obj); end

  def self.status_code_for_exception(class_name); end
end

class ActionDispatch::Executor
  def call(env); end

  def initialize(app, executor); end
end

class ActionDispatch::Executor
end

class ActionDispatch::Flash
  KEY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Flash::FlashHash
  include ::Enumerable
  def [](k); end

  def []=(k, v); end

  def alert(); end

  def alert=(message); end

  def clear(); end

  def delete(key); end

  def discard(k=T.unsafe(nil)); end

  def each(&block); end

  def empty?(); end

  def initialize(flashes=T.unsafe(nil), discard=T.unsafe(nil)); end

  def keep(k=T.unsafe(nil)); end

  def key?(name); end

  def keys(); end

  def merge!(h); end

  def notice(); end

  def notice=(message); end

  def now(); end

  def now_is_loaded?(); end

  def replace(h); end

  def sweep(); end

  def to_hash(); end

  def to_session_value(); end

  def update(h); end
end

class ActionDispatch::Flash::FlashHash
  def self.from_session_value(value); end
end

class ActionDispatch::Flash::FlashNow
  def [](k); end

  def []=(k, v); end

  def alert=(message); end

  def flash(); end

  def flash=(flash); end

  def initialize(flash); end

  def notice=(message); end
end

class ActionDispatch::Flash::FlashNow
end

module ActionDispatch::Flash::RequestMethods
  def commit_flash(); end

  def flash(); end

  def flash=(flash); end

  def flash_hash(); end

  def reset_session(); end
end

module ActionDispatch::Flash::RequestMethods
end

class ActionDispatch::Flash
  def self.new(app); end
end

module ActionDispatch::Http::Cache
end

module ActionDispatch::Http::Cache::Request
  def etag_matches?(etag); end

  def fresh?(response); end

  def if_modified_since(); end

  def if_none_match(); end

  def if_none_match_etags(); end

  def not_modified?(modified_at); end
  HTTP_IF_MODIFIED_SINCE = ::T.let(nil, ::T.untyped)
  HTTP_IF_NONE_MATCH = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::Cache::Request
end

module ActionDispatch::Http::Cache::Response
  def cache_control(); end

  def date(); end

  def date=(utc_time); end

  def date?(); end

  def etag=(weak_validators); end

  def etag?(); end

  def last_modified(); end

  def last_modified=(utc_time); end

  def last_modified?(); end

  def strong_etag=(strong_validators); end

  def strong_etag?(); end

  def weak_etag=(weak_validators); end

  def weak_etag?(); end
  DATE = ::T.let(nil, ::T.untyped)
  DEFAULT_CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  LAST_MODIFIED = ::T.let(nil, ::T.untyped)
  MUST_REVALIDATE = ::T.let(nil, ::T.untyped)
  NO_CACHE = ::T.let(nil, ::T.untyped)
  PRIVATE = ::T.let(nil, ::T.untyped)
  PUBLIC = ::T.let(nil, ::T.untyped)
  SPECIAL_KEYS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::Cache::Response
end

module ActionDispatch::Http::Cache
end

module ActionDispatch::Http::FilterParameters
  def filtered_env(); end

  def filtered_parameters(); end

  def filtered_path(); end

  def initialize(); end
  ENV_MATCH = ::T.let(nil, ::T.untyped)
  KV_RE = ::T.let(nil, ::T.untyped)
  NULL_ENV_FILTER = ::T.let(nil, ::T.untyped)
  NULL_PARAM_FILTER = ::T.let(nil, ::T.untyped)
  PAIR_RE = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::FilterParameters
end

module ActionDispatch::Http::FilterRedirect
  def filtered_location(); end
  FILTERED = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::FilterRedirect
end

class ActionDispatch::Http::Headers
  include ::Enumerable
  def [](key); end

  def []=(key, value); end

  def add(key, value); end

  def each(&block); end

  def env(); end

  def fetch(key, default=T.unsafe(nil)); end

  def include?(key); end

  def initialize(request); end

  def key?(key); end

  def merge(headers_or_env); end

  def merge!(headers_or_env); end
  CGI_VARIABLES = ::T.let(nil, ::T.untyped)
  DEFAULT = ::T.let(nil, ::T.untyped)
  HTTP_HEADER = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Http::Headers
  def self.from_hash(hash); end
end

module ActionDispatch::Http::MimeNegotiation
  def accepts(); end

  def content_mime_type(); end

  def content_type(); end

  def format(view_path=T.unsafe(nil)); end

  def format=(extension); end

  def formats(); end

  def formats=(extensions); end

  def has_content_type?(); end

  def negotiate_mime(order); end

  def variant(); end

  def variant=(variant); end
  BROWSER_LIKE_ACCEPTS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::MimeNegotiation
  extend ::ActiveSupport::Concern
end

class ActionDispatch::Http::ParameterFilter
  def filter(params); end

  def initialize(filters=T.unsafe(nil)); end
  FILTERED = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Http::ParameterFilter::CompiledFilter
  def blocks(); end

  def call(original_params, parents=T.unsafe(nil)); end

  def deep_regexps(); end

  def initialize(regexps, deep_regexps, blocks); end

  def regexps(); end
end

class ActionDispatch::Http::ParameterFilter::CompiledFilter
  def self.compile(filters); end
end

class ActionDispatch::Http::ParameterFilter
end

module ActionDispatch::Http::Parameters
  def path_parameters(); end

  def path_parameters=(parameters); end
  DEFAULT_PARSERS = ::T.let(nil, ::T.untyped)
  PARAMETERS_KEY = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::Parameters::ClassMethods
  def parameter_parsers=(parsers); end
end

module ActionDispatch::Http::Parameters::ClassMethods
end

class ActionDispatch::Http::Parameters::ParseError
  def initialize(); end
end

class ActionDispatch::Http::Parameters::ParseError
end

module ActionDispatch::Http::Parameters
  extend ::ActiveSupport::Concern
end

module ActionDispatch::Http::URL
  def domain(tld_length=T.unsafe(nil)); end

  def host(); end

  def host_with_port(); end

  def initialize(); end

  def optional_port(); end

  def port(); end

  def port_string(); end

  def protocol(); end

  def raw_host_with_port(); end

  def server_port(); end

  def standard_port(); end

  def standard_port?(); end

  def subdomain(tld_length=T.unsafe(nil)); end

  def subdomains(tld_length=T.unsafe(nil)); end

  def tld_length(); end

  def tld_length=(obj); end

  def url(); end
  HOST_REGEXP = ::T.let(nil, ::T.untyped)
  IP_HOST_REGEXP = ::T.let(nil, ::T.untyped)
  PROTOCOL_REGEXP = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::URL
  def self.extract_domain(host, tld_length); end

  def self.extract_subdomain(host, tld_length); end

  def self.extract_subdomains(host, tld_length); end

  def self.full_url_for(options); end

  def self.path_for(options); end

  def self.tld_length(); end

  def self.tld_length=(obj); end

  def self.url_for(options); end
end

class ActionDispatch::Http::UploadedFile
  def close(unlink_now=T.unsafe(nil)); end

  def content_type(); end

  def content_type=(content_type); end

  def eof?(); end

  def headers(); end

  def headers=(headers); end

  def initialize(hash); end

  def open(); end

  def original_filename(); end

  def original_filename=(original_filename); end

  def path(); end

  def read(length=T.unsafe(nil), buffer=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def tempfile(); end

  def tempfile=(tempfile); end

  def to_io(); end
end

class ActionDispatch::Http::UploadedFile
end

module ActionDispatch::Integration::Runner
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  def app(); end

  def assigns(*args); end

  def before_setup(); end

  def cookies(*args); end

  def copy_session_variables!(); end

  def create_session(app); end

  def default_url_options(); end

  def default_url_options=(options); end

  def delete(*args); end

  def follow_redirect!(*args); end

  def get(*args); end

  def head(*args); end

  def initialize(*args, &blk); end

  def integration_session(); end

  def open_session(); end

  def patch(*args); end

  def post(*args); end

  def put(*args); end

  def remove!(); end

  def reset!(); end
  APP_SESSIONS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Integration::Runner
end

class ActionDispatch::IntegrationTest
  include ::ActionDispatch::TestProcess::FixtureFile
end

module ActionDispatch::IntegrationTest::Behavior
  include ::ActionDispatch::Integration::Runner
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
end

module ActionDispatch::IntegrationTest::Behavior
  extend ::ActiveSupport::Concern
end

module ActionDispatch::IntegrationTest::UrlOptions
  def url_options(); end
end

module ActionDispatch::IntegrationTest::UrlOptions
  extend ::ActiveSupport::Concern
end

class ActionDispatch::IntegrationTest
end

module ActionDispatch::Journey
end

class ActionDispatch::Journey::Format
  def evaluate(hash); end

  def initialize(parts); end
  ESCAPE_PATH = ::T.let(nil, ::T.untyped)
  ESCAPE_SEGMENT = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Format::Parameter
  def escape(value); end

  def escaper(); end

  def escaper=(_); end

  def name(); end

  def name=(_); end
end

class ActionDispatch::Journey::Format::Parameter
  def self.[](*_); end

  def self.members(); end
end

class ActionDispatch::Journey::Format
  def self.required_path(symbol); end

  def self.required_segment(symbol); end
end

class ActionDispatch::Journey::Formatter
  def clear(); end

  def generate(name, options, path_parameters, parameterize=T.unsafe(nil)); end

  def initialize(routes); end

  def routes(); end
end

module ActionDispatch::Journey::Formatter::RegexCaseComparator
  DEFAULT_INPUT = ::T.let(nil, ::T.untyped)
  DEFAULT_REGEX = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Journey::Formatter::RegexCaseComparator
  def self.===(regex); end
end

class ActionDispatch::Journey::Formatter
end

module ActionDispatch::Journey::GTG
end

class ActionDispatch::Journey::GTG::Builder
  def ast(); end

  def endpoints(); end

  def firstpos(node); end

  def followpos(node); end

  def initialize(root); end

  def lastpos(node); end

  def nullable?(node); end

  def root(); end

  def transition_table(); end
  DUMMY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::GTG::Builder
end

class ActionDispatch::Journey::GTG::MatchData
  def initialize(memos); end

  def memos(); end
end

class ActionDispatch::Journey::GTG::MatchData
end

class ActionDispatch::Journey::GTG::Simulator
  def initialize(transition_table); end

  def memos(string); end

  def tt(); end
end

class ActionDispatch::Journey::GTG::Simulator
end

class ActionDispatch::Journey::GTG::TransitionTable
  include ::ActionDispatch::Journey::NFA::Dot
  def []=(from, to, sym); end

  def accepting?(state); end

  def accepting_states(); end

  def add_accepting(state); end

  def add_memo(idx, memo); end

  def eclosure(t); end

  def memo(idx); end

  def memos(); end

  def move(t, a); end

  def states(); end

  def to_svg(); end

  def transitions(); end

  def visualizer(paths, title=T.unsafe(nil)); end
end

class ActionDispatch::Journey::GTG::TransitionTable
end

module ActionDispatch::Journey::GTG
end

module ActionDispatch::Journey::NFA
end

class ActionDispatch::Journey::NFA::Builder
  def initialize(ast); end

  def transition_table(); end
end

class ActionDispatch::Journey::NFA::Builder
end

module ActionDispatch::Journey::NFA::Dot
  def to_dot(); end
end

module ActionDispatch::Journey::NFA::Dot
end

class ActionDispatch::Journey::NFA::MatchData
  def initialize(memos); end

  def memos(); end
end

class ActionDispatch::Journey::NFA::MatchData
end

class ActionDispatch::Journey::NFA::Simulator
  def =~(string); end

  def initialize(transition_table); end

  def match(string); end

  def simulate(string); end

  def tt(); end
end

class ActionDispatch::Journey::NFA::Simulator
end

class ActionDispatch::Journey::NFA::TransitionTable
  include ::ActionDispatch::Journey::NFA::Dot
  def []=(i, f, s); end

  def accepting(); end

  def accepting=(accepting); end

  def accepting?(state); end

  def accepting_states(); end

  def add_memo(idx, memo); end

  def alphabet(); end

  def eclosure(t); end

  def following_states(t, a); end

  def memo(idx); end

  def memos(); end

  def merge(left, right); end

  def move(t, a); end

  def states(); end

  def transitions(); end
end

class ActionDispatch::Journey::NFA::TransitionTable
end

class ActionDispatch::Journey::NFA::Visitor
  def initialize(tt); end

  def visit_CAT(node); end

  def visit_GROUP(node); end

  def visit_OR(node); end
end

class ActionDispatch::Journey::NFA::Visitor
end

module ActionDispatch::Journey::NFA
end

module ActionDispatch::Journey::Nodes
end

class ActionDispatch::Journey::Nodes::Binary
  def children(); end

  def initialize(left, right); end

  def right(); end

  def right=(right); end
end

class ActionDispatch::Journey::Nodes::Binary
end

class ActionDispatch::Journey::Nodes::Cat
end

class ActionDispatch::Journey::Nodes::Cat
end

class ActionDispatch::Journey::Nodes::Dot
end

class ActionDispatch::Journey::Nodes::Dot
end

class ActionDispatch::Journey::Nodes::Dummy
  def initialize(x=T.unsafe(nil)); end
end

class ActionDispatch::Journey::Nodes::Dummy
end

class ActionDispatch::Journey::Nodes::Group
end

class ActionDispatch::Journey::Nodes::Group
end

class ActionDispatch::Journey::Nodes::Literal
end

class ActionDispatch::Journey::Nodes::Literal
end

class ActionDispatch::Journey::Nodes::Node
  include ::Enumerable
  def cat?(); end

  def each(&block); end

  def group?(); end

  def initialize(left); end

  def left(); end

  def left=(left); end

  def literal?(); end

  def memo(); end

  def memo=(memo); end

  def name(); end

  def star?(); end

  def symbol?(); end

  def terminal?(); end

  def to_dot(); end

  def to_sym(); end

  def type(); end
end

class ActionDispatch::Journey::Nodes::Node
end

class ActionDispatch::Journey::Nodes::Or
  def children(); end

  def initialize(children); end
end

class ActionDispatch::Journey::Nodes::Or
end

class ActionDispatch::Journey::Nodes::Slash
end

class ActionDispatch::Journey::Nodes::Slash
end

class ActionDispatch::Journey::Nodes::Star
end

class ActionDispatch::Journey::Nodes::Star
end

class ActionDispatch::Journey::Nodes::Symbol
  def default_regexp?(); end

  def regexp(); end

  def regexp=(regexp); end
  DEFAULT_EXP = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Nodes::Symbol
end

class ActionDispatch::Journey::Nodes::Terminal
  def symbol(); end
end

class ActionDispatch::Journey::Nodes::Terminal
end

class ActionDispatch::Journey::Nodes::Unary
  def children(); end
end

class ActionDispatch::Journey::Nodes::Unary
end

module ActionDispatch::Journey::Nodes
end

class ActionDispatch::Journey::Parser
  include ::ActionDispatch::Journey::Nodes
  def _reduce_1(val, _values); end

  def _reduce_10(val, _values); end

  def _reduce_15(val, _values); end

  def _reduce_16(val, _values); end

  def _reduce_17(val, _values); end

  def _reduce_18(val, _values); end

  def _reduce_2(val, _values); end

  def _reduce_7(val, _values); end

  def _reduce_8(val, _values); end

  def _reduce_9(val, _values); end

  def _reduce_none(val, _values); end

  def parse(string); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Parser
  def self.parse(string); end
end

module ActionDispatch::Journey::Path
end

class ActionDispatch::Journey::Path::Pattern
  def =~(other); end

  def anchored(); end

  def ast(); end

  def build_formatter(); end

  def eager_load!(); end

  def initialize(ast, requirements, separators, anchored); end

  def match(other); end

  def names(); end

  def optional_names(); end

  def required_names(); end

  def requirements(); end

  def source(); end

  def spec(); end

  def to_regexp(); end
end

class ActionDispatch::Journey::Path::Pattern::AnchoredRegexp
  def initialize(separator, matchers); end

  def visit_CAT(node); end

  def visit_DOT(node); end

  def visit_GROUP(node); end

  def visit_LITERAL(node); end

  def visit_OR(node); end

  def visit_SLASH(node); end

  def visit_STAR(node); end

  def visit_SYMBOL(node); end
end

class ActionDispatch::Journey::Path::Pattern::AnchoredRegexp
end

class ActionDispatch::Journey::Path::Pattern::MatchData
  def [](x); end

  def captures(); end

  def initialize(names, offsets, match); end

  def length(); end

  def names(); end

  def post_match(); end
end

class ActionDispatch::Journey::Path::Pattern::MatchData
end

class ActionDispatch::Journey::Path::Pattern::UnanchoredRegexp
end

class ActionDispatch::Journey::Path::Pattern::UnanchoredRegexp
end

class ActionDispatch::Journey::Path::Pattern
  def self.build(path, requirements, separators, anchored); end

  def self.from_string(string); end
end

module ActionDispatch::Journey::Path
end

class ActionDispatch::Journey::Route
  def app(); end

  def ast(); end

  def conditions(); end

  def constraints(); end

  def defaults(); end

  def dispatcher?(); end

  def eager_load!(); end

  def format(path_options); end

  def glob?(); end

  def initialize(name, app, path, constraints, required_defaults, defaults, request_method_match, precedence, internal=T.unsafe(nil)); end

  def internal(); end

  def ip(); end

  def matches?(request); end

  def name(); end

  def parts(); end

  def path(); end

  def precedence(); end

  def required_default?(key); end

  def required_defaults(); end

  def required_keys(); end

  def required_parts(); end

  def requirements(); end

  def requires_matching_verb?(); end

  def score(supplied_keys); end

  def segment_keys(); end

  def segments(); end

  def verb(); end
end

module ActionDispatch::Journey::Route::VerbMatchers
  VERBS = ::T.let(nil, ::T.untyped)
  VERB_TO_CLASS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Route::VerbMatchers::All
end

class ActionDispatch::Journey::Route::VerbMatchers::All
  def self.call(_); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::DELETE
end

class ActionDispatch::Journey::Route::VerbMatchers::DELETE
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::GET
end

class ActionDispatch::Journey::Route::VerbMatchers::GET
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::HEAD
end

class ActionDispatch::Journey::Route::VerbMatchers::HEAD
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::LINK
end

class ActionDispatch::Journey::Route::VerbMatchers::LINK
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::OPTIONS
end

class ActionDispatch::Journey::Route::VerbMatchers::OPTIONS
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::PATCH
end

class ActionDispatch::Journey::Route::VerbMatchers::PATCH
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::POST
end

class ActionDispatch::Journey::Route::VerbMatchers::POST
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::PUT
end

class ActionDispatch::Journey::Route::VerbMatchers::PUT
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::TRACE
end

class ActionDispatch::Journey::Route::VerbMatchers::TRACE
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::UNLINK
end

class ActionDispatch::Journey::Route::VerbMatchers::UNLINK
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::Unknown
  def call(request); end

  def initialize(verb); end

  def verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::Unknown
end

module ActionDispatch::Journey::Route::VerbMatchers
end

class ActionDispatch::Journey::Route
  def self.build(name, app, path, constraints, required_defaults, defaults); end

  def self.verb_matcher(verb); end
end

class ActionDispatch::Journey::Router
  def eager_load!(); end

  def initialize(routes); end

  def recognize(rails_req); end

  def routes(); end

  def routes=(routes); end

  def serve(req); end

  def visualizer(); end
end

class ActionDispatch::Journey::Router::RoutingError
end

class ActionDispatch::Journey::Router::RoutingError
end

class ActionDispatch::Journey::Router::Utils
  ENCODER = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Router::Utils::UriEncoder
  def escape_fragment(fragment); end

  def escape_path(path); end

  def escape_segment(segment); end

  def unescape_uri(uri); end
  ALPHA = ::T.let(nil, ::T.untyped)
  DEC2HEX = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ENCODE = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  SEGMENT = ::T.let(nil, ::T.untyped)
  SUB_DELIMS = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Router::Utils::UriEncoder
end

class ActionDispatch::Journey::Router::Utils
  def self.escape_fragment(fragment); end

  def self.escape_path(path); end

  def self.escape_segment(segment); end

  def self.normalize_path(path); end

  def self.unescape_uri(uri); end
end

class ActionDispatch::Journey::Router
end

class ActionDispatch::Journey::Routes
  include ::Enumerable
  def add_route(name, mapping); end

  def anchored_routes(); end

  def ast(); end

  def clear(); end

  def custom_routes(); end

  def each(&block); end

  def empty?(); end

  def last(); end

  def length(); end

  def partition_route(route); end

  def routes(); end

  def simulator(); end

  def size(); end
end

class ActionDispatch::Journey::Routes
end

class ActionDispatch::Journey::Scanner
  def eos?(); end

  def next_token(); end

  def pos(); end

  def pre_match(); end

  def scan_setup(str); end
end

class ActionDispatch::Journey::Scanner
end

module ActionDispatch::Journey::Visitors
end

class ActionDispatch::Journey::Visitors::Dot
  def accept(node, seed=T.unsafe(nil)); end
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Dot
end

class ActionDispatch::Journey::Visitors::Each
  def visit(node, block); end
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Each
end

class ActionDispatch::Journey::Visitors::FormatBuilder
end

class ActionDispatch::Journey::Visitors::FormatBuilder
end

class ActionDispatch::Journey::Visitors::FunctionalVisitor
  def accept(node, seed); end

  def binary(node, seed); end

  def nary(node, seed); end

  def terminal(node, seed); end

  def unary(node, seed); end

  def visit(node, seed); end

  def visit_CAT(n, seed); end

  def visit_DOT(n, seed); end

  def visit_GROUP(n, seed); end

  def visit_LITERAL(n, seed); end

  def visit_OR(n, seed); end

  def visit_SLASH(n, seed); end

  def visit_STAR(n, seed); end

  def visit_SYMBOL(n, seed); end
  DISPATCH_CACHE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::FunctionalVisitor
end

class ActionDispatch::Journey::Visitors::String
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::String
end

class ActionDispatch::Journey::Visitors::Visitor
  def accept(node); end
  DISPATCH_CACHE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Visitor
end

module ActionDispatch::Journey::Visitors
end

module ActionDispatch::Journey
end

class ActionDispatch::MiddlewareStack
  include ::Enumerable
  def [](i); end

  def build(app=T.unsafe(nil), &block); end

  def delete(target); end

  def each(&blk); end

  def initialize(*args); end

  def insert(index, klass, *args, &block); end

  def insert_after(index, *args, &block); end

  def insert_before(index, klass, *args, &block); end

  def last(); end

  def middlewares(); end

  def middlewares=(middlewares); end

  def size(); end

  def swap(target, *args, &block); end

  def unshift(klass, *args, &block); end

  def use(klass, *args, &block); end
end

class ActionDispatch::MiddlewareStack::Middleware
  def ==(middleware); end

  def args(); end

  def block(); end

  def build(app); end

  def initialize(klass, args, block); end

  def klass(); end

  def name(); end
end

class ActionDispatch::MiddlewareStack::Middleware
end

class ActionDispatch::MiddlewareStack
end

class ActionDispatch::PublicExceptions
  def call(env); end

  def initialize(public_path); end

  def public_path(); end

  def public_path=(public_path); end
end

class ActionDispatch::PublicExceptions
end

class ActionDispatch::Reloader
end

class ActionDispatch::Reloader
end

class ActionDispatch::RemoteIp
  def call(env); end

  def check_ip(); end

  def initialize(app, ip_spoofing_check=T.unsafe(nil), custom_proxies=T.unsafe(nil)); end

  def proxies(); end
  TRUSTED_PROXIES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::RemoteIp::GetIp
  def calculate_ip(); end

  def initialize(req, check_ip, proxies); end
end

class ActionDispatch::RemoteIp::GetIp
end

class ActionDispatch::RemoteIp::IpSpoofAttackError
end

class ActionDispatch::RemoteIp::IpSpoofAttackError
end

class ActionDispatch::RemoteIp
end

class ActionDispatch::Request
  include ::Rack::Request::Helpers
  include ::ActionDispatch::Http::Cache::Request
  include ::ActionDispatch::Http::MimeNegotiation
  include ::ActionDispatch::Http::Parameters
  include ::ActionDispatch::Http::FilterParameters
  include ::ActionDispatch::Http::URL
  include ::ActionDispatch::ContentSecurityPolicy::Request
  include ::Rack::Request::Env
  include ::ActionDispatch::Flash::RequestMethods
  def accept(); end

  def accept_charset(); end

  def auth_type(); end

  def authenticated_encrypted_cookie_salt(); end

  def authorization(); end

  def body_stream(); end

  def cache_control(); end

  def client_ip(); end

  def controller_class(); end

  def controller_class_for(name); end

  def controller_instance(); end

  def controller_instance=(controller); end

  def cookie_jar(); end

  def cookie_jar=(jar); end

  def cookies_digest(); end

  def cookies_rotations(); end

  def cookies_serializer(); end

  def encrypted_cookie_cipher(); end

  def encrypted_cookie_salt(); end

  def encrypted_signed_cookie_salt(); end

  def engine_script_name(_routes); end

  def engine_script_name=(name); end

  def from(); end

  def gateway_interface(); end

  def have_cookie_jar?(); end

  def headers(); end

  def http_auth_salt(); end

  def ignore_accept_header(); end

  def ignore_accept_header=(obj); end

  def key?(key); end

  def key_generator(); end

  def local?(); end

  def method(); end

  def method_symbol(); end

  def negotiate(); end

  def origin(); end

  def original_fullpath(); end

  def original_script_name(); end

  def original_url(); end

  def path_translated(); end

  def pragma(); end

  def query_parameters(); end

  def raw_post(); end

  def remote_addr(); end

  def remote_host(); end

  def remote_ident(); end

  def remote_ip(); end

  def remote_ip=(remote_ip); end

  def remote_user(); end

  def request_id(); end

  def request_id=(id); end

  def request_method=(request_method); end

  def request_method_symbol(); end

  def request_parameters(); end

  def request_parameters=(params); end

  def routes(); end

  def routes=(routes); end

  def secret_key_base(); end

  def secret_token(); end

  def send_early_hints(links); end

  def server_addr(); end

  def server_name(); end

  def server_protocol(); end

  def server_software(); end

  def session=(session); end

  def session_options=(options); end

  def show_exceptions?(); end

  def signed_cookie_digest(); end

  def signed_cookie_salt(); end

  def use_authenticated_cookie_encryption(); end

  def uuid(); end

  def version(); end

  def x_csrf_token(); end

  def x_forwarded_for(); end

  def x_forwarded_host(); end

  def x_request_id(); end

  def xml_http_request?(); end
  ACTION_DISPATCH_REQUEST_ID = ::T.let(nil, ::T.untyped)
  ENV_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_LOOKUP = ::T.let(nil, ::T.untyped)
  LOCALHOST = ::T.let(nil, ::T.untyped)
  RFC2518 = ::T.let(nil, ::T.untyped)
  RFC2616 = ::T.let(nil, ::T.untyped)
  RFC3253 = ::T.let(nil, ::T.untyped)
  RFC3648 = ::T.let(nil, ::T.untyped)
  RFC3744 = ::T.let(nil, ::T.untyped)
  RFC4791 = ::T.let(nil, ::T.untyped)
  RFC5323 = ::T.let(nil, ::T.untyped)
  RFC5789 = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Request::PASS_NOT_FOUND
end

class ActionDispatch::Request::PASS_NOT_FOUND
  def self.action(_); end

  def self.binary_params_for?(action); end

  def self.call(_); end
end

class ActionDispatch::Request::Session
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def delete(key); end

  def destroy(); end

  def each(&block); end

  def empty?(); end

  def exists?(); end

  def fetch(key, default=T.unsafe(nil), &block); end

  def has_key?(key); end

  def id(); end

  def include?(key); end

  def initialize(by, req); end

  def key?(key); end

  def keys(); end

  def loaded?(); end

  def merge!(other); end

  def options(); end

  def to_h(); end

  def to_hash(); end

  def update(hash); end

  def values(); end
  ENV_SESSION_KEY = ::T.let(nil, ::T.untyped)
  ENV_SESSION_OPTIONS_KEY = ::T.let(nil, ::T.untyped)
  Unspecified = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Request::Session::Options
  def [](key); end

  def []=(k, v); end

  def id(req); end

  def initialize(by, default_options); end

  def to_hash(); end

  def values_at(*args); end
end

class ActionDispatch::Request::Session::Options
  def self.find(req); end

  def self.set(req, options); end
end

class ActionDispatch::Request::Session
  def self.create(store, req, default_options); end

  def self.find(req); end

  def self.set(req, session); end
end

class ActionDispatch::Request::Utils
  def perform_deep_munge(); end

  def perform_deep_munge=(obj); end
end

class ActionDispatch::Request::Utils::NoNilParamEncoder
end

class ActionDispatch::Request::Utils::NoNilParamEncoder
end

class ActionDispatch::Request::Utils::ParamEncoder
end

class ActionDispatch::Request::Utils::ParamEncoder
  def self.handle_array(params); end

  def self.normalize_encode_params(params); end
end

class ActionDispatch::Request::Utils
  def self.check_param_encoding(params); end

  def self.each_param_value(params, &block); end

  def self.normalize_encode_params(params); end

  def self.perform_deep_munge(); end

  def self.perform_deep_munge=(obj); end
end

class ActionDispatch::Request
  extend ::ActionDispatch::Http::Parameters::ClassMethods
  def self.empty(); end

  def self.ignore_accept_header(); end

  def self.ignore_accept_header=(obj); end

  def self.parameter_parsers(); end
end

class ActionDispatch::RequestId
  def call(env); end

  def initialize(app); end
  X_REQUEST_ID = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::RequestId
end

class ActionDispatch::Response
  include ::Rack::Response::Helpers
  include ::ActionDispatch::Http::FilterRedirect
  include ::ActionDispatch::Http::Cache::Response
  include ::MonitorMixin
  def [](*args, &block); end

  def []=(*args, &block); end

  def _cache_control(); end

  def _cache_control=(v); end

  def abort(); end

  def await_commit(); end

  def await_sent(); end

  def body(); end

  def body=(body); end

  def body_parts(); end

  def charset(); end

  def charset=(charset); end

  def close(); end

  def code(); end

  def commit!(); end

  def committed?(); end

  def content_type=(content_type); end

  def cookies(); end

  def default_charset(); end

  def default_charset=(obj); end

  def default_headers(); end

  def default_headers=(obj); end

  def delete_header(key); end

  def each(&block); end

  def get_header(key); end

  def has_header?(key); end

  def header(); end

  def headers(); end

  def initialize(status=T.unsafe(nil), header=T.unsafe(nil), body=T.unsafe(nil)); end

  def message(); end

  def prepare!(); end

  def redirect_url(); end

  def request(); end

  def request=(request); end

  def reset_body!(); end

  def response_code(); end

  def send_file(path); end

  def sending!(); end

  def sending?(); end

  def sending_file=(v); end

  def sent!(); end

  def sent?(); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end

  def status_message(); end

  def stream(); end

  def to_a(); end

  def write(string); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  LOCATION = ::T.let(nil, ::T.untyped)
  NO_CONTENT_CODES = ::T.let(nil, ::T.untyped)
  NullContentTypeHeader = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Response::Buffer
  def abort(); end

  def body(); end

  def close(); end

  def closed?(); end

  def each(&block); end

  def initialize(response, buf); end

  def write(string); end
end

class ActionDispatch::Response::Buffer
end

class ActionDispatch::Response::ContentTypeHeader
  def charset(); end

  def charset=(_); end

  def mime_type(); end

  def mime_type=(_); end
end

class ActionDispatch::Response::ContentTypeHeader
  def self.[](*_); end

  def self.members(); end
end

class ActionDispatch::Response::FileBody
  def body(); end

  def each(&blk); end

  def initialize(path); end

  def to_path(); end
end

class ActionDispatch::Response::FileBody
end

class ActionDispatch::Response::Header
  def []=(k, v); end

  def initialize(response, header); end

  def merge(other); end

  def to_hash(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Response::Header
end

class ActionDispatch::Response::RackBody
  def body(); end

  def close(); end

  def each(*args, &block); end

  def initialize(response); end

  def respond_to?(method, include_private=T.unsafe(nil)); end

  def to_ary(); end

  def to_path(); end
end

class ActionDispatch::Response::RackBody
end

class ActionDispatch::Response
  def self.create(status=T.unsafe(nil), header=T.unsafe(nil), body=T.unsafe(nil), default_headers: T.unsafe(nil)); end

  def self.default_charset(); end

  def self.default_charset=(obj); end

  def self.default_headers(); end

  def self.default_headers=(obj); end

  def self.merge_default_headers(original, default); end
end

module ActionDispatch::Routing
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  SEPARATORS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::ConsoleFormatter
  def header(routes); end

  def no_routes(routes); end

  def result(); end

  def section(routes); end

  def section_title(title); end
end

class ActionDispatch::Routing::ConsoleFormatter
end

class ActionDispatch::Routing::Endpoint
  def app(); end

  def dispatcher?(); end

  def engine?(); end

  def matches?(req); end

  def rack_app(); end

  def redirect?(); end
end

class ActionDispatch::Routing::Endpoint
end

class ActionDispatch::Routing::HtmlTableFormatter
  def header(routes); end

  def initialize(view); end

  def no_routes(*_); end

  def result(); end

  def section(routes); end

  def section_title(title); end
end

class ActionDispatch::Routing::HtmlTableFormatter
end

class ActionDispatch::Routing::Mapper
  include ::ActionDispatch::Routing::Mapper::Base
  include ::ActionDispatch::Routing::Mapper::HttpHelpers
  include ::ActionDispatch::Routing::Redirection
  include ::ActionDispatch::Routing::Mapper::Scoping
  include ::ActionDispatch::Routing::Mapper::Concerns
  include ::ActionDispatch::Routing::Mapper::Resources
  include ::ActionDispatch::Routing::Mapper::CustomUrls
  def initialize(set); end
  URL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::Base
  def default_url_options(options); end

  def default_url_options=(options); end

  def has_named_route?(name); end

  def match(path, options=T.unsafe(nil)); end

  def mount(app, options=T.unsafe(nil)); end

  def with_default_scope(scope, &block); end
end

module ActionDispatch::Routing::Mapper::Base
end

module ActionDispatch::Routing::Mapper::Concerns
  def concern(name, callable=T.unsafe(nil), &block); end

  def concerns(*args); end
end

module ActionDispatch::Routing::Mapper::Concerns
end

class ActionDispatch::Routing::Mapper::Constraints
  def constraints(); end

  def initialize(app, constraints, strategy); end

  def serve(req); end
  CALL = ::T.let(nil, ::T.untyped)
  SERVE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Constraints
end

module ActionDispatch::Routing::Mapper::CustomUrls
  def direct(name, options=T.unsafe(nil), &block); end

  def resolve(*args, &block); end
end

module ActionDispatch::Routing::Mapper::CustomUrls
end

class ActionDispatch::Routing::Mapper::Mapping
  def application(); end

  def ast(); end

  def conditions(); end

  def default_action(); end

  def default_controller(); end

  def defaults(); end

  def initialize(set, ast, defaults, controller, default_action, modyoule, to, formatted, scope_constraints, blocks, via, options_constraints, anchor, options); end

  def make_route(name, precedence); end

  def path(); end

  def required_defaults(); end

  def requirements(); end

  def to(); end
  ANCHOR_CHARACTERS_REGEX = ::T.let(nil, ::T.untyped)
  JOINED_SEPARATORS = ::T.let(nil, ::T.untyped)
  OPTIONAL_FORMAT_REGEX = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Mapping
  def self.build(scope, set, ast, controller, default_action, to, via, formatted, options_constraints, anchor, options); end

  def self.check_via(via); end

  def self.normalize_path(path, format); end

  def self.optional_format?(path, format); end
end

module ActionDispatch::Routing::Mapper::Resources
  def nested(); end

  def new(); end

  def resources_path_names(options); end
  CANONICAL_ACTIONS = ::T.let(nil, ::T.untyped)
  RESOURCE_OPTIONS = ::T.let(nil, ::T.untyped)
  VALID_ON_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Resources::Resource
  def actions(); end

  def collection_name(); end

  def collection_scope(); end

  def controller(); end

  def default_actions(); end

  def initialize(entities, api_only, shallow, options=T.unsafe(nil)); end

  def member_name(); end

  def member_scope(); end

  def name(); end

  def nested_param(); end

  def nested_scope(); end

  def new_scope(new_path); end

  def param(); end

  def path(); end

  def plural(); end

  def resource_scope(); end

  def shallow?(); end

  def shallow_scope(); end

  def singleton?(); end

  def singular(); end
end

class ActionDispatch::Routing::Mapper::Resources::Resource
end

class ActionDispatch::Routing::Mapper::Resources::SingletonResource
  def initialize(entities, api_only, shallow, options); end
end

class ActionDispatch::Routing::Mapper::Resources::SingletonResource
end

class ActionDispatch::Routing::Mapper::Scope
  include ::Enumerable
  def [](key); end

  def action_name(name_prefix, prefix, collection_name, member_name); end

  def each(&blk); end

  def frame(); end

  def initialize(hash, parent=T.unsafe(nil), scope_level=T.unsafe(nil)); end

  def nested?(); end

  def new(hash); end

  def new_level(level); end

  def null?(); end

  def options(); end

  def parent(); end

  def resource_method_scope?(); end

  def resource_scope?(); end

  def resources?(); end

  def root?(); end

  def scope_level(); end
  NULL = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  RESOURCE_METHOD_SCOPES = ::T.let(nil, ::T.untyped)
  RESOURCE_SCOPES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Scope
end

module ActionDispatch::Routing::Mapper::Scoping
  def constraints(constraints=T.unsafe(nil)); end

  def controller(controller); end

  def defaults(defaults=T.unsafe(nil)); end

  def namespace(path, options=T.unsafe(nil)); end

  def scope(*args); end
  POISON = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::Scoping
end

class ActionDispatch::Routing::Mapper
  def self.normalize_name(name); end

  def self.normalize_path(path); end
end

module ActionDispatch::Routing::PolymorphicRoutes
  def edit_polymorphic_path(record_or_hash, options=T.unsafe(nil)); end

  def edit_polymorphic_url(record_or_hash, options=T.unsafe(nil)); end

  def new_polymorphic_path(record_or_hash, options=T.unsafe(nil)); end

  def new_polymorphic_url(record_or_hash, options=T.unsafe(nil)); end

  def polymorphic_path(record_or_hash_or_array, options=T.unsafe(nil)); end

  def polymorphic_url(record_or_hash_or_array, options=T.unsafe(nil)); end
end

class ActionDispatch::Routing::PolymorphicRoutes::HelperMethodBuilder
  def handle_class(klass); end

  def handle_class_call(target, klass); end

  def handle_list(list); end

  def handle_model(record); end

  def handle_model_call(target, record); end

  def handle_string(record); end

  def handle_string_call(target, str); end

  def initialize(key_strategy, prefix, suffix); end

  def prefix(); end

  def suffix(); end
  CACHE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::PolymorphicRoutes::HelperMethodBuilder
  def self.build(action, type); end

  def self.get(action, type); end

  def self.path(); end

  def self.plural(prefix, suffix); end

  def self.polymorphic_method(recipient, record_or_hash_or_array, action, type, options); end

  def self.singular(prefix, suffix); end

  def self.url(); end
end

module ActionDispatch::Routing::PolymorphicRoutes
end

module ActionDispatch::Routing::Redirection
  def redirect(*args, &block); end
end

module ActionDispatch::Routing::Redirection
end

class ActionDispatch::Routing::RouteSet
  def add_polymorphic_mapping(klass, options, &block); end

  def add_route(mapping, name); end

  def add_url_helper(name, options, &block); end

  def api_only?(); end

  def append(&block); end

  def call(env); end

  def clear!(); end

  def default_scope(); end

  def default_scope=(default_scope); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def define_mounted_helper(name, script_namer=T.unsafe(nil)); end

  def disable_clear_and_finalize(); end

  def disable_clear_and_finalize=(disable_clear_and_finalize); end

  def eager_load!(); end

  def empty?(); end

  def env_key(); end

  def extra_keys(options, recall=T.unsafe(nil)); end

  def finalize!(); end

  def find_relative_url_root(options); end

  def find_script_name(options); end

  def formatter(); end

  def formatter=(formatter); end

  def generate_extras(options, recall=T.unsafe(nil)); end

  def initialize(config=T.unsafe(nil)); end

  def mounted_helpers(); end

  def named_routes(); end

  def named_routes=(named_routes); end

  def optimize_routes_generation?(); end

  def path_for(options, route_name=T.unsafe(nil)); end

  def polymorphic_mappings(); end

  def prepend(&block); end

  def recognize_path(path, environment=T.unsafe(nil)); end

  def recognize_path_with_request(req, path, extras, raise_on_missing: T.unsafe(nil)); end

  def relative_url_root(); end

  def request_class(); end

  def resources_path_names(); end

  def resources_path_names=(resources_path_names); end

  def router(); end

  def router=(router); end

  def routes(); end

  def set(); end

  def set=(set); end

  def url_for(options, route_name=T.unsafe(nil), url_strategy=T.unsafe(nil)); end

  def url_helpers(supports_path=T.unsafe(nil)); end
  DEFAULT_CONFIG = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  RESERVED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RouteSet::Config
  def api_only(); end

  def api_only=(_); end

  def relative_url_root(); end

  def relative_url_root=(_); end
end

class ActionDispatch::Routing::RouteSet::Config
  def self.[](*_); end

  def self.members(); end
end

class ActionDispatch::Routing::RouteSet::CustomUrlHelper
  def block(); end

  def call(t, args, only_path=T.unsafe(nil)); end

  def defaults(); end

  def initialize(name, defaults, &block); end

  def name(); end
end

class ActionDispatch::Routing::RouteSet::CustomUrlHelper
end

class ActionDispatch::Routing::RouteSet::Dispatcher
  def initialize(raise_on_name_error); end

  def serve(req); end
end

class ActionDispatch::Routing::RouteSet::Dispatcher
end

class ActionDispatch::Routing::RouteSet::Generator
  def controller(); end

  def current_controller(); end

  def different_controller?(); end

  def generate(); end

  def initialize(named_route, options, recall, set); end

  def named_route(); end

  def normalize_controller!(); end

  def normalize_controller_action_id!(); end

  def normalize_options!(); end

  def options(); end

  def recall(); end

  def set(); end

  def use_recall_for(key); end

  def use_relative_controller!(); end
  PARAMETERIZE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RouteSet::Generator
end

module ActionDispatch::Routing::RouteSet::MountedHelpers
end

module ActionDispatch::Routing::RouteSet::MountedHelpers
  extend ::ActiveSupport::Concern
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection
  include ::Enumerable
  def [](name); end

  def []=(name, route); end

  def add(name, route); end

  def add_url_helper(name, defaults, &block); end

  def clear(); end

  def clear!(); end

  def each(&blk); end

  def get(name); end

  def helper_names(); end

  def key?(name); end

  def length(); end

  def names(); end

  def path_helpers_module(); end

  def route_defined?(name); end

  def url_helpers_module(); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper
  def call(t, args, inner_options); end

  def handle_positional_args(controller_options, inner_options, args, result, path_params); end

  def initialize(route, options, route_name, url_strategy); end

  def route_name(); end

  def url_strategy(); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper::OptimizedUrlHelper
  def arg_size(); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper::OptimizedUrlHelper
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper
  def self.create(route, options, route_name, url_strategy); end

  def self.optimize_helper?(route); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection
end

class ActionDispatch::Routing::RouteSet::StaticDispatcher
  def initialize(controller_class); end
end

class ActionDispatch::Routing::RouteSet::StaticDispatcher
end

class ActionDispatch::Routing::RouteSet
  def self.default_resources_path_names(); end

  def self.new_with_config(config); end
end

class ActionDispatch::Routing::RouteWrapper
  def action(); end

  def constraints(); end

  def controller(); end

  def endpoint(); end

  def engine?(); end

  def internal?(); end

  def name(); end

  def path(); end

  def rack_app(); end

  def reqs(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RouteWrapper
end

class ActionDispatch::Routing::RoutesInspector
  def format(formatter, filter=T.unsafe(nil)); end

  def initialize(routes); end
end

class ActionDispatch::Routing::RoutesInspector
end

class ActionDispatch::Routing::RoutesProxy
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def _routes(); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def initialize(routes, scope, helpers, script_namer=T.unsafe(nil)); end

  def routes(); end

  def routes=(routes); end

  def scope(); end

  def scope=(scope); end
end

class ActionDispatch::Routing::RoutesProxy
  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end
end

module ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def full_url_for(options=T.unsafe(nil)); end

  def initialize(*_); end

  def optimize_routes_generation?(); end

  def route_for(name, *args); end

  def url_for(options=T.unsafe(nil)); end

  def url_options(); end
end

module ActionDispatch::Routing::UrlFor
  extend ::ActiveSupport::Concern
end

module ActionDispatch::Routing
  extend ::ActiveSupport::Autoload
end

class ActionDispatch::SSL
  def call(env); end

  def initialize(app, redirect: T.unsafe(nil), hsts: T.unsafe(nil), secure_cookies: T.unsafe(nil)); end
  HSTS_EXPIRES_IN = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::SSL
  def self.default_hsts_options(); end
end

class ActionDispatch::Session::AbstractSecureStore
  include ::ActionDispatch::Session::Compatibility
  include ::ActionDispatch::Session::StaleSessionCheck
  include ::ActionDispatch::Session::SessionObject
end

class ActionDispatch::Session::AbstractSecureStore
end

class ActionDispatch::Session::AbstractStore
  include ::ActionDispatch::Session::Compatibility
  include ::ActionDispatch::Session::StaleSessionCheck
  include ::ActionDispatch::Session::SessionObject
end

class ActionDispatch::Session::AbstractStore
end

class ActionDispatch::Session::CacheStore
  def delete_session(env, sid, options); end

  def write_session(env, sid, session, options); end
end

class ActionDispatch::Session::CacheStore
end

module ActionDispatch::Session::Compatibility
  def generate_sid(); end

  def initialize(app, options=T.unsafe(nil)); end
end

module ActionDispatch::Session::Compatibility
end

class ActionDispatch::Session::CookieStore
  def delete_session(req, session_id, options); end

  def load_session(req); end
end

class ActionDispatch::Session::CookieStore::SessionId
  def cookie_value(); end

  def initialize(session_id, cookie_value=T.unsafe(nil)); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Session::CookieStore::SessionId
end

class ActionDispatch::Session::CookieStore
end

module ActionDispatch::Session::SessionObject
  def loaded_session?(session); end

  def prepare_session(req); end
end

module ActionDispatch::Session::SessionObject
end

module ActionDispatch::Session::StaleSessionCheck
  def extract_session_id(env); end

  def load_session(env); end

  def stale_session_check!(); end
end

module ActionDispatch::Session::StaleSessionCheck
end

class ActionDispatch::ShowExceptions
  def call(env); end

  def initialize(app, exceptions_app); end
  FAILSAFE_RESPONSE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::ShowExceptions
end

class ActionDispatch::Static
  def call(env); end

  def initialize(app, path, index: T.unsafe(nil), headers: T.unsafe(nil)); end
end

class ActionDispatch::Static
end

module ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  def assigns(key=T.unsafe(nil)); end

  def cookies(); end

  def flash(); end

  def redirect_to_url(); end

  def session(); end
end

module ActionDispatch::TestProcess::FixtureFile
  def fixture_file_upload(path, mime_type=T.unsafe(nil), binary=T.unsafe(nil)); end
end

module ActionDispatch::TestProcess::FixtureFile
end

module ActionDispatch::TestProcess
end

class ActionDispatch::TestRequest
  def accept=(mime_types); end

  def action=(action_name); end

  def host=(host); end

  def if_modified_since=(last_modified); end

  def if_none_match=(etag); end

  def path=(path); end

  def port=(number); end

  def remote_addr=(addr); end

  def request_method=(method); end

  def request_uri=(uri); end

  def user_agent=(user_agent); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::TestRequest
  def self.create(env=T.unsafe(nil)); end
end

class ActionDispatch::TestResponse
  def error?(); end

  def initialize(*_); end

  def missing?(); end

  def parsed_body(); end

  def success?(); end
end

class ActionDispatch::TestResponse
  def self.from_response(response); end
end

module ActionPack::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class ActionView::Base
  include ::ActionView::Context
  include ::ActionView::CompiledTemplates
  include ::ERB::Util
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::UrlHelper
  include ::ActionView::Helpers::FormTagHelper
  include ::ActionView::Helpers::FormHelper
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  include ::ActionView::Helpers::TranslationHelper
  include ::ActionView::Helpers
  include ::ActiveSupport::Benchmarkable
  include ::ActionView::Helpers::ActiveModelHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::ActionView::Helpers::AtomFeedHelper
  include ::ActionView::Helpers::CacheHelper
  include ::ActionView::Helpers::ControllerHelper
  include ::ActionView::Helpers::CspHelper
  include ::ActionView::Helpers::CsrfHelper
  include ::ActionView::Helpers::DateHelper
  include ::ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::JavaScriptHelper
  include ::ActionView::Helpers::NumberHelper
  include ::ActionView::Helpers::RecordTagHelper
  include ::ActionView::Helpers::RenderingHelper
  def _routes(); end

  def _routes=(val); end

  def _routes?(); end

  def assign(new_assigns); end

  def assigns(); end

  def assigns=(assigns); end

  def automatically_disable_submit_tag(); end

  def automatically_disable_submit_tag=(obj); end

  def config(); end

  def config=(config); end

  def debug_missing_translation(); end

  def debug_missing_translation=(obj); end

  def default_formats(); end

  def default_formats=(obj); end

  def field_error_proc(); end

  def field_error_proc=(obj); end

  def formats(*args, &block); end

  def formats=(arg); end

  def initialize(context=T.unsafe(nil), assigns=T.unsafe(nil), controller=T.unsafe(nil), formats=T.unsafe(nil)); end

  def locale(*args, &block); end

  def locale=(arg); end

  def logger=(val); end

  def logger?(); end

  def lookup_context(*args, &block); end

  def prefix_partial_path_with_controller_namespace(); end

  def prefix_partial_path_with_controller_namespace=(obj); end

  def raise_on_missing_translations(); end

  def raise_on_missing_translations=(obj); end

  def streaming_completion_on_exception(); end

  def streaming_completion_on_exception=(obj); end

  def view_paths(*args, &block); end

  def view_paths=(arg); end

  def view_renderer(); end

  def view_renderer=(view_renderer); end
end

class ActionView::Base
  def self._routes(); end

  def self._routes=(val); end

  def self._routes?(); end

  def self.automatically_disable_submit_tag(); end

  def self.automatically_disable_submit_tag=(obj); end

  def self.cache_template_loading(); end

  def self.cache_template_loading=(value); end

  def self.debug_missing_translation(); end

  def self.debug_missing_translation=(obj); end

  def self.default_form_builder(); end

  def self.default_form_builder=(obj); end

  def self.default_formats(); end

  def self.default_formats=(obj); end

  def self.erb_trim_mode=(arg); end

  def self.field_error_proc(); end

  def self.field_error_proc=(obj); end

  def self.logger(); end

  def self.logger=(val); end

  def self.logger?(); end

  def self.prefix_partial_path_with_controller_namespace(); end

  def self.prefix_partial_path_with_controller_namespace=(obj); end

  def self.raise_on_missing_translations(); end

  def self.raise_on_missing_translations=(obj); end

  def self.streaming_completion_on_exception(); end

  def self.streaming_completion_on_exception=(obj); end

  def self.xss_safe?(); end
end

module ActionView::CompiledTemplates
end

module ActionView::CompiledTemplates
end

module ActionView::Context
  include ::ActionView::CompiledTemplates
  def _layout_for(name=T.unsafe(nil)); end

  def _prepare_context(); end

  def output_buffer(); end

  def output_buffer=(output_buffer); end

  def view_flow(); end

  def view_flow=(view_flow); end
end

module ActionView::Context
end

module ActionView::Helpers
  include ::ActiveSupport::Benchmarkable
  include ::ActionView::Helpers::ActiveModelHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::ActionView::Helpers::AtomFeedHelper
  include ::ActionView::Helpers::CacheHelper
  include ::ActionView::Helpers::ControllerHelper
  include ::ActionView::Helpers::CspHelper
  include ::ActionView::Helpers::CsrfHelper
  include ::ActionView::Helpers::DateHelper
  include ::ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::JavaScriptHelper
  include ::ActionView::Helpers::NumberHelper
  include ::ActionView::Helpers::RecordTagHelper
  include ::ActionView::Helpers::RenderingHelper
end

module ActionView::Helpers::ActiveModelHelper
end

module ActionView::Helpers::ActiveModelHelper
end

module ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AssetUrlHelper
  def audio_tag(*sources); end

  def auto_discovery_link_tag(type=T.unsafe(nil), url_options=T.unsafe(nil), tag_options=T.unsafe(nil)); end

  def favicon_link_tag(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def image_alt(src); end

  def image_tag(source, options=T.unsafe(nil)); end

  def javascript_include_tag(*sources); end

  def preload_link_tag(source, options=T.unsafe(nil)); end

  def stylesheet_link_tag(*sources); end

  def video_tag(*sources); end
end

module ActionView::Helpers::AssetTagHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers::AssetUrlHelper
  def asset_path(source, options=T.unsafe(nil)); end

  def asset_url(source, options=T.unsafe(nil)); end

  def audio_path(source, options=T.unsafe(nil)); end

  def audio_url(source, options=T.unsafe(nil)); end

  def compute_asset_extname(source, options=T.unsafe(nil)); end

  def compute_asset_host(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def compute_asset_path(source, options=T.unsafe(nil)); end

  def font_path(source, options=T.unsafe(nil)); end

  def font_url(source, options=T.unsafe(nil)); end

  def image_path(source, options=T.unsafe(nil)); end

  def image_url(source, options=T.unsafe(nil)); end

  def javascript_path(source, options=T.unsafe(nil)); end

  def javascript_url(source, options=T.unsafe(nil)); end

  def path_to_asset(source, options=T.unsafe(nil)); end

  def path_to_audio(source, options=T.unsafe(nil)); end

  def path_to_font(source, options=T.unsafe(nil)); end

  def path_to_image(source, options=T.unsafe(nil)); end

  def path_to_javascript(source, options=T.unsafe(nil)); end

  def path_to_stylesheet(source, options=T.unsafe(nil)); end

  def path_to_video(source, options=T.unsafe(nil)); end

  def public_compute_asset_path(source, options=T.unsafe(nil)); end

  def stylesheet_path(source, options=T.unsafe(nil)); end

  def stylesheet_url(source, options=T.unsafe(nil)); end

  def url_to_asset(source, options=T.unsafe(nil)); end

  def url_to_audio(source, options=T.unsafe(nil)); end

  def url_to_font(source, options=T.unsafe(nil)); end

  def url_to_image(source, options=T.unsafe(nil)); end

  def url_to_javascript(source, options=T.unsafe(nil)); end

  def url_to_stylesheet(source, options=T.unsafe(nil)); end

  def url_to_video(source, options=T.unsafe(nil)); end

  def video_path(source, options=T.unsafe(nil)); end

  def video_url(source, options=T.unsafe(nil)); end
  ASSET_EXTENSIONS = ::T.let(nil, ::T.untyped)
  ASSET_PUBLIC_DIRECTORIES = ::T.let(nil, ::T.untyped)
  URI_REGEXP = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::AssetUrlHelper
end

module ActionView::Helpers::AtomFeedHelper
  def atom_feed(options=T.unsafe(nil), &block); end
end

module ActionView::Helpers::AtomFeedHelper
end

module ActionView::Helpers::CacheHelper
  def cache(name=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def cache_fragment_name(name=T.unsafe(nil), skip_digest: T.unsafe(nil), virtual_path: T.unsafe(nil)); end

  def cache_if(condition, name=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def cache_unless(condition, name=T.unsafe(nil), options=T.unsafe(nil), &block); end
end

module ActionView::Helpers::CacheHelper
end

module ActionView::Helpers::CaptureHelper
  def capture(*args); end

  def content_for(name, content=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def content_for?(name); end

  def provide(name, content=T.unsafe(nil), &block); end

  def with_output_buffer(buf=T.unsafe(nil)); end
end

module ActionView::Helpers::CaptureHelper
end

module ActionView::Helpers::ControllerHelper
  def action_name(*args, &block); end

  def assign_controller(controller); end

  def controller(); end

  def controller=(controller); end

  def controller_name(*args, &block); end

  def controller_path(*args, &block); end

  def cookies(*args, &block); end

  def flash(*args, &block); end

  def headers(*args, &block); end

  def logger(); end

  def params(*args, &block); end

  def request(); end

  def request=(request); end

  def request_forgery_protection_token(*args, &block); end

  def respond_to?(method_name, include_private=T.unsafe(nil)); end

  def response(*args, &block); end

  def session(*args, &block); end
  CONTROLLER_DELEGATES = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::ControllerHelper
end

module ActionView::Helpers::CspHelper
  def csp_meta_tag(); end
end

module ActionView::Helpers::CspHelper
end

module ActionView::Helpers::CsrfHelper
  def csrf_meta_tag(); end

  def csrf_meta_tags(); end
end

module ActionView::Helpers::CsrfHelper
end

module ActionView::Helpers::DateHelper
  def date_select(object_name, method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def datetime_select(object_name, method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def distance_of_time_in_words(from_time, to_time=T.unsafe(nil), options=T.unsafe(nil)); end

  def distance_of_time_in_words_to_now(from_time, options=T.unsafe(nil)); end

  def select_date(date=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_datetime(datetime=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_day(date, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_hour(datetime, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_minute(datetime, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_month(date, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_second(datetime, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_time(datetime=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_year(date, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def time_ago_in_words(from_time, options=T.unsafe(nil)); end

  def time_select(object_name, method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def time_tag(date_or_time, *args, &block); end
  MINUTES_IN_QUARTER_YEAR = ::T.let(nil, ::T.untyped)
  MINUTES_IN_THREE_QUARTERS_YEAR = ::T.let(nil, ::T.untyped)
  MINUTES_IN_YEAR = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::DateHelper
end

module ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def debug(object); end
end

module ActionView::Helpers::DebugHelper
end

module ActionView::Helpers::FormHelper
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  def check_box(object_name, method, options=T.unsafe(nil), checked_value=T.unsafe(nil), unchecked_value=T.unsafe(nil)); end

  def color_field(object_name, method, options=T.unsafe(nil)); end

  def date_field(object_name, method, options=T.unsafe(nil)); end

  def datetime_field(object_name, method, options=T.unsafe(nil)); end

  def datetime_local_field(object_name, method, options=T.unsafe(nil)); end

  def default_form_builder(); end

  def default_form_builder=(default_form_builder); end

  def email_field(object_name, method, options=T.unsafe(nil)); end

  def fields(scope=T.unsafe(nil), model: T.unsafe(nil), **options, &block); end

  def fields_for(record_name, record_object=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def file_field(object_name, method, options=T.unsafe(nil)); end

  def form_for(record, options=T.unsafe(nil), &block); end

  def form_with(model: T.unsafe(nil), scope: T.unsafe(nil), url: T.unsafe(nil), format: T.unsafe(nil), **options, &block); end

  def form_with_generates_ids(); end

  def form_with_generates_ids=(obj); end

  def form_with_generates_remote_forms(); end

  def form_with_generates_remote_forms=(obj); end

  def hidden_field(object_name, method, options=T.unsafe(nil)); end

  def label(object_name, method, content_or_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def month_field(object_name, method, options=T.unsafe(nil)); end

  def number_field(object_name, method, options=T.unsafe(nil)); end

  def password_field(object_name, method, options=T.unsafe(nil)); end

  def phone_field(object_name, method, options=T.unsafe(nil)); end

  def radio_button(object_name, method, tag_value, options=T.unsafe(nil)); end

  def range_field(object_name, method, options=T.unsafe(nil)); end

  def search_field(object_name, method, options=T.unsafe(nil)); end

  def telephone_field(object_name, method, options=T.unsafe(nil)); end

  def text_area(object_name, method, options=T.unsafe(nil)); end

  def text_field(object_name, method, options=T.unsafe(nil)); end

  def time_field(object_name, method, options=T.unsafe(nil)); end

  def url_field(object_name, method, options=T.unsafe(nil)); end

  def week_field(object_name, method, options=T.unsafe(nil)); end
end

module ActionView::Helpers::FormHelper
  extend ::ActiveSupport::Concern
  def self.form_with_generates_ids(); end

  def self.form_with_generates_ids=(obj); end

  def self.form_with_generates_remote_forms(); end

  def self.form_with_generates_remote_forms=(obj); end
end

module ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def collection_check_boxes(object, method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def collection_radio_buttons(object, method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def collection_select(object, method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def grouped_collection_select(object, method, collection, group_method, group_label_method, option_key_method, option_value_method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def grouped_options_for_select(grouped_options, selected_key=T.unsafe(nil), options=T.unsafe(nil)); end

  def option_groups_from_collection_for_select(collection, group_method, group_label_method, option_key_method, option_value_method, selected_key=T.unsafe(nil)); end

  def options_for_select(container, selected=T.unsafe(nil)); end

  def options_from_collection_for_select(collection, value_method, text_method, selected=T.unsafe(nil)); end

  def select(object, method, choices=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def time_zone_options_for_select(selected=T.unsafe(nil), priority_zones=T.unsafe(nil), model=T.unsafe(nil)); end

  def time_zone_select(object, method, priority_zones=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end
end

module ActionView::Helpers::FormOptionsHelper
end

module ActionView::Helpers::FormTagHelper
  def button_tag(content_or_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def check_box_tag(name, value=T.unsafe(nil), checked=T.unsafe(nil), options=T.unsafe(nil)); end

  def color_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def date_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def datetime_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def datetime_local_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def email_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def embed_authenticity_token_in_remote_forms(); end

  def embed_authenticity_token_in_remote_forms=(obj); end

  def field_set_tag(legend=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def file_field_tag(name, options=T.unsafe(nil)); end

  def form_tag(url_for_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def hidden_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def image_submit_tag(source, options=T.unsafe(nil)); end

  def label_tag(name=T.unsafe(nil), content_or_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def month_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def number_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def password_field_tag(name=T.unsafe(nil), value=T.unsafe(nil), options=T.unsafe(nil)); end

  def phone_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def radio_button_tag(name, value, checked=T.unsafe(nil), options=T.unsafe(nil)); end

  def range_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def search_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def select_tag(name, option_tags=T.unsafe(nil), options=T.unsafe(nil)); end

  def submit_tag(value=T.unsafe(nil), options=T.unsafe(nil)); end

  def telephone_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def text_area_tag(name, content=T.unsafe(nil), options=T.unsafe(nil)); end

  def text_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def time_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def url_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def utf8_enforcer_tag(); end

  def week_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActionView::Helpers::FormTagHelper
  extend ::ActiveSupport::Concern
  def self.embed_authenticity_token_in_remote_forms(); end

  def self.embed_authenticity_token_in_remote_forms=(obj); end
end

module ActionView::Helpers::JavaScriptHelper
  def escape_javascript(javascript); end

  def j(javascript); end

  def javascript_cdata_section(content); end

  def javascript_tag(content_or_options_with_block=T.unsafe(nil), html_options=T.unsafe(nil), &block); end
  JS_ESCAPE_MAP = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::JavaScriptHelper
end

module ActionView::Helpers::NumberHelper
  def number_to_currency(number, options=T.unsafe(nil)); end

  def number_to_human(number, options=T.unsafe(nil)); end

  def number_to_human_size(number, options=T.unsafe(nil)); end

  def number_to_percentage(number, options=T.unsafe(nil)); end

  def number_to_phone(number, options=T.unsafe(nil)); end

  def number_with_delimiter(number, options=T.unsafe(nil)); end

  def number_with_precision(number, options=T.unsafe(nil)); end
end

module ActionView::Helpers::NumberHelper
end

module ActionView::Helpers::OutputSafetyHelper
  def raw(stringish); end

  def safe_join(array, sep=T.unsafe(nil)); end

  def to_sentence(array, options=T.unsafe(nil)); end
end

module ActionView::Helpers::OutputSafetyHelper
end

module ActionView::Helpers::RecordTagHelper
  def content_tag_for(*_); end

  def div_for(*_); end
end

module ActionView::Helpers::RecordTagHelper
end

module ActionView::Helpers::RenderingHelper
  def _layout_for(*args, &block); end

  def render(options=T.unsafe(nil), locals=T.unsafe(nil), &block); end
end

module ActionView::Helpers::RenderingHelper
end

module ActionView::Helpers::SanitizeHelper
  def sanitize(html, options=T.unsafe(nil)); end

  def sanitize_css(style); end

  def strip_links(html); end

  def strip_tags(html); end
end

module ActionView::Helpers::SanitizeHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def cdata_section(content); end

  def content_tag(name, content_or_options_with_block=T.unsafe(nil), options=T.unsafe(nil), escape=T.unsafe(nil), &block); end

  def escape_once(html); end

  def tag(name=T.unsafe(nil), options=T.unsafe(nil), open=T.unsafe(nil), escape=T.unsafe(nil)); end
  BOOLEAN_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  PRE_CONTENT_STRINGS = ::T.let(nil, ::T.untyped)
  TAG_PREFIXES = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::TagHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def concat(string); end

  def current_cycle(name=T.unsafe(nil)); end

  def cycle(first_value, *values); end

  def excerpt(text, phrase, options=T.unsafe(nil)); end

  def highlight(text, phrases, options=T.unsafe(nil)); end

  def pluralize(count, singular, plural_arg=T.unsafe(nil), plural: T.unsafe(nil), locale: T.unsafe(nil)); end

  def reset_cycle(name=T.unsafe(nil)); end

  def safe_concat(string); end

  def simple_format(text, html_options=T.unsafe(nil), options=T.unsafe(nil)); end

  def truncate(text, options=T.unsafe(nil), &block); end

  def word_wrap(text, line_width: T.unsafe(nil), break_sequence: T.unsafe(nil)); end
end

module ActionView::Helpers::TextHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers::TranslationHelper
  def l(*args); end

  def localize(*args); end

  def t(key, options=T.unsafe(nil)); end

  def translate(key, options=T.unsafe(nil)); end
end

module ActionView::Helpers::TranslationHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers::UrlHelper
  def _back_url(); end

  def _filtered_referrer(); end

  def button_to(name=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def current_page?(options, check_parameters: T.unsafe(nil)); end

  def link_to(name=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def link_to_if(condition, name, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def link_to_unless(condition, name, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def link_to_unless_current(name, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def mail_to(email_address, name=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def url_for(options=T.unsafe(nil)); end
  BUTTON_TAG_METHOD_VERBS = ::T.let(nil, ::T.untyped)
  STRINGIFIED_COMMON_METHODS = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::UrlHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers
  extend ::ActiveSupport::Autoload
  extend ::ActiveSupport::Concern
end

module ActionView::ModelNaming
  def convert_to_model(object); end

  def model_name_from_record_or_class(record_or_class); end
end

module ActionView::ModelNaming
end

module ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  def dom_class(record_or_class, prefix=T.unsafe(nil)); end

  def dom_id(record, prefix=T.unsafe(nil)); end
  JOIN = ::T.let(nil, ::T.untyped)
  NEW = ::T.let(nil, ::T.untyped)
end

module ActionView::RecordIdentifier
  extend ::ActionView::RecordIdentifier
  extend ::ActionView::ModelNaming
end

class ActiveRecordOverrides
  def self.instance(); end
end

module ActiveSupport
  def parse_json_times(); end

  def parse_json_times=(obj); end
end

class ActiveSupport::ArrayInquirer
  def any?(*candidates); end
end

class ActiveSupport::ArrayInquirer
end

class ActiveSupport::BacktraceCleaner
  def add_filter(&block); end

  def add_silencer(&block); end

  def clean(backtrace, kind=T.unsafe(nil)); end

  def filter(backtrace, kind=T.unsafe(nil)); end

  def remove_filters!(); end

  def remove_silencers!(); end
end

class ActiveSupport::BacktraceCleaner
end

module ActiveSupport::Benchmarkable
  def benchmark(message=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActiveSupport::Benchmarkable
end

module ActiveSupport::Cache
  UNIVERSAL_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::Entry
  def dup_value!(); end

  def expired?(); end

  def expires_at(); end

  def expires_at=(value); end

  def initialize(value, compress: T.unsafe(nil), compress_threshold: T.unsafe(nil), version: T.unsafe(nil), expires_in: T.unsafe(nil), **_); end

  def mismatched?(version); end

  def size(); end

  def value(); end

  def version(); end
  DEFAULT_COMPRESS_LIMIT = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::Entry
end

class ActiveSupport::Cache::FileStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
  def cache_path(); end

  def initialize(cache_path, options=T.unsafe(nil)); end
  DIR_FORMATTER = ::T.let(nil, ::T.untyped)
  EXCLUDED_DIRS = ::T.let(nil, ::T.untyped)
  FILENAME_MAX_SIZE = ::T.let(nil, ::T.untyped)
  FILEPATH_MAX_SIZE = ::T.let(nil, ::T.untyped)
  GITKEEP_FILES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::FileStore
end

class ActiveSupport::Cache::MemoryStore
  def prune(target_size, max_time=T.unsafe(nil)); end

  def pruning?(); end

  def synchronize(&block); end
  PER_ENTRY_OVERHEAD = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::MemoryStore
end

class ActiveSupport::Cache::NullStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
end

class ActiveSupport::Cache::NullStore
end

class ActiveSupport::Cache::Store
  def cleanup(options=T.unsafe(nil)); end

  def clear(options=T.unsafe(nil)); end

  def decrement(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete(name, options=T.unsafe(nil)); end

  def delete_matched(matcher, options=T.unsafe(nil)); end

  def exist?(name, options=T.unsafe(nil)); end

  def fetch(name, options=T.unsafe(nil)); end

  def fetch_multi(*names); end

  def increment(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def logger(); end

  def logger=(obj); end

  def mute(); end

  def options(); end

  def read(name, options=T.unsafe(nil)); end

  def read_multi(*names); end

  def silence(); end

  def silence!(); end

  def silence?(); end

  def write(name, value, options=T.unsafe(nil)); end

  def write_multi(hash, options=T.unsafe(nil)); end
end

class ActiveSupport::Cache::Store
  def self.logger(); end

  def self.logger=(obj); end
end

module ActiveSupport::Cache::Strategy
end

module ActiveSupport::Cache::Strategy::LocalCache
  def cleanup(options=T.unsafe(nil)); end

  def clear(options=T.unsafe(nil)); end

  def decrement(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def increment(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def middleware(); end

  def with_local_cache(); end
end

module ActiveSupport::Cache::Strategy::LocalCache
end

module ActiveSupport::Cache::Strategy
end

module ActiveSupport::Cache
  def self.expand_cache_key(key, namespace=T.unsafe(nil)); end

  def self.lookup_store(*store_option); end
end

module ActiveSupport::Callbacks
  def run_callbacks(kind); end
  CALLBACK_FILTER_TYPES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Callbacks
  extend ::ActiveSupport::Concern
end

module ActiveSupport::Concurrency
end

class ActiveSupport::Concurrency::ShareLock
  include ::MonitorMixin
  def exclusive(purpose: T.unsafe(nil), compatible: T.unsafe(nil), after_compatible: T.unsafe(nil), no_wait: T.unsafe(nil)); end

  def initialize(); end

  def raw_state(); end

  def sharing(); end

  def start_exclusive(purpose: T.unsafe(nil), compatible: T.unsafe(nil), no_wait: T.unsafe(nil)); end

  def start_sharing(); end

  def stop_exclusive(compatible: T.unsafe(nil)); end

  def stop_sharing(); end

  def yield_shares(purpose: T.unsafe(nil), compatible: T.unsafe(nil), block_share: T.unsafe(nil)); end
end

class ActiveSupport::Concurrency::ShareLock
end

module ActiveSupport::Concurrency
end

module ActiveSupport::Configurable
  def config(); end
end

module ActiveSupport::Configurable::ClassMethods
  def config(); end

  def configure(); end
end

module ActiveSupport::Configurable::ClassMethods
end

class ActiveSupport::Configurable::Configuration
  def compile_methods!(); end
end

class ActiveSupport::Configurable::Configuration
  def self.compile_methods!(keys); end
end

module ActiveSupport::Configurable
  extend ::ActiveSupport::Concern
end

class ActiveSupport::CurrentAttributes
  include ::ActiveSupport::Callbacks
  def __callbacks(); end

  def __callbacks?(); end

  def _reset_callbacks(); end

  def _run_reset_callbacks(&block); end

  def attributes(); end

  def attributes=(attributes); end

  def reset(); end

  def set(set_attributes); end
end

class ActiveSupport::CurrentAttributes
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._reset_callbacks(); end

  def self._reset_callbacks=(value); end

  def self.attribute(*names); end

  def self.clear_all(); end

  def self.instance(); end

  def self.reset(*args, &block); end

  def self.reset_all(); end

  def self.resets(&block); end

  def self.set(*args, &block); end
end

module ActiveSupport::Dependencies
  def autoload_module!(into, const_name, qualified_name, path_suffix); end

  def autoload_once_paths(); end

  def autoload_once_paths=(obj); end

  def autoload_paths(); end

  def autoload_paths=(obj); end

  def autoloadable_module?(path_suffix); end

  def autoloaded?(desc); end

  def autoloaded_constants(); end

  def autoloaded_constants=(obj); end

  def clear(); end

  def constant_watch_stack(); end

  def constant_watch_stack=(obj); end

  def constantize(name); end

  def depend_on(file_name, message=T.unsafe(nil)); end

  def explicitly_unloadable_constants(); end

  def explicitly_unloadable_constants=(obj); end

  def history(); end

  def history=(obj); end

  def hook!(); end

  def interlock(); end

  def interlock=(obj); end

  def load?(); end

  def load_file(path, const_paths=T.unsafe(nil)); end

  def load_missing_constant(from_mod, const_name); end

  def load_once_path?(path); end

  def loadable_constants_for_path(path, bases=T.unsafe(nil)); end

  def loaded(); end

  def loaded=(obj); end

  def loading(); end

  def loading=(obj); end

  def mark_for_unload(const_desc); end

  def mechanism(); end

  def mechanism=(obj); end

  def new_constants_in(*descs); end

  def qualified_const_defined?(path); end

  def qualified_name_for(mod, name); end

  def reference(klass); end

  def remove_constant(const); end

  def remove_unloadable_constants!(); end

  def require_or_load(file_name, const_path=T.unsafe(nil)); end

  def safe_constantize(name); end

  def search_for_file(path_suffix); end

  def to_constant_name(desc); end

  def unhook!(); end

  def warnings_on_first_load(); end

  def warnings_on_first_load=(obj); end

  def will_unload?(const_desc); end
  Reference = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Dependencies::Blamable
  def blame_file!(file); end

  def blamed_files(); end

  def copy_blame!(exc); end

  def describe_blame(); end
end

module ActiveSupport::Dependencies::Blamable
end

class ActiveSupport::Dependencies::ClassCache
  def [](key); end

  def clear!(); end

  def empty?(); end

  def get(key); end

  def key?(key); end

  def safe_get(key); end

  def store(klass); end
end

class ActiveSupport::Dependencies::ClassCache
end

class ActiveSupport::Dependencies::Interlock
  def done_running(); end

  def done_unloading(); end

  def loading(); end

  def permit_concurrent_loads(); end

  def raw_state(&block); end

  def running(); end

  def start_running(); end

  def start_unloading(); end

  def unloading(); end
end

class ActiveSupport::Dependencies::Interlock
end

module ActiveSupport::Dependencies::Loadable
  def load_dependency(file); end

  def require_dependency(file_name, message=T.unsafe(nil)); end

  def require_or_load(file_name); end

  def unloadable(const_desc); end
end

module ActiveSupport::Dependencies::Loadable
  def self.exclude_from(base); end
end

module ActiveSupport::Dependencies::ModuleConstMissing
  def const_missing(const_name); end

  def guess_for_anonymous(const_name); end

  def unloadable(const_desc=T.unsafe(nil)); end
end

module ActiveSupport::Dependencies::ModuleConstMissing
  def self.append_features(base); end

  def self.exclude_from(base); end
end

class ActiveSupport::Dependencies::WatchStack
  include ::Enumerable
  def each(&block); end

  def new_constants(); end

  def watch_namespaces(namespaces); end

  def watching(); end

  def watching?(); end
end

class ActiveSupport::Dependencies::WatchStack
end

module ActiveSupport::Dependencies
  extend ::ActiveSupport::Dependencies
  def self.load_interlock(); end

  def self.run_interlock(); end

  def self.unload_interlock(); end
end

class ActiveSupport::Deprecation
  def deprecation_horizon(); end

  def deprecation_horizon=(deprecation_horizon); end

  def initialize(deprecation_horizon=T.unsafe(nil), gem_name=T.unsafe(nil)); end
  DEFAULT_BEHAVIORS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Deprecation::Reporting
  RAILS_GEM_ROOT = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Deprecation
  extend ::ActiveSupport::Deprecation::InstanceDelegator::OverrideDelegators
end

module ActiveSupport::DescendantsTracker
  def descendants(); end

  def direct_descendants(); end

  def inherited(base); end
end

module ActiveSupport::DescendantsTracker
  def self.clear(); end

  def self.descendants(klass); end

  def self.direct_descendants(klass); end

  def self.store_inherited(klass, descendant); end
end

class ActiveSupport::Digest
end

class ActiveSupport::Digest
  def self.hash_digest_class(); end

  def self.hash_digest_class=(klass); end

  def self.hexdigest(arg); end
end

class ActiveSupport::Duration
  PARTS = ::T.let(nil, ::T.untyped)
  PARTS_IN_SECONDS = ::T.let(nil, ::T.untyped)
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
  SECONDS_PER_HOUR = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MINUTE = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MONTH = ::T.let(nil, ::T.untyped)
  SECONDS_PER_WEEK = ::T.let(nil, ::T.untyped)
  SECONDS_PER_YEAR = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Parser
  def initialize(string); end

  def mode(); end

  def mode=(mode); end

  def parse!(); end

  def parts(); end

  def scanner(); end

  def sign(); end

  def sign=(sign); end
  COMMA = ::T.let(nil, ::T.untyped)
  DATE_COMPONENT = ::T.let(nil, ::T.untyped)
  DATE_COMPONENTS = ::T.let(nil, ::T.untyped)
  DATE_MARKER = ::T.let(nil, ::T.untyped)
  DATE_TO_PART = ::T.let(nil, ::T.untyped)
  PERIOD = ::T.let(nil, ::T.untyped)
  PERIOD_OR_COMMA = ::T.let(nil, ::T.untyped)
  SIGN_MARKER = ::T.let(nil, ::T.untyped)
  TIME_COMPONENT = ::T.let(nil, ::T.untyped)
  TIME_COMPONENTS = ::T.let(nil, ::T.untyped)
  TIME_MARKER = ::T.let(nil, ::T.untyped)
  TIME_TO_PART = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Parser::ParsingError
end

class ActiveSupport::Duration::ISO8601Parser::ParsingError
end

class ActiveSupport::Duration::ISO8601Parser
end

class ActiveSupport::Duration::ISO8601Serializer
  def initialize(duration, precision: T.unsafe(nil)); end

  def serialize(); end
end

class ActiveSupport::Duration::ISO8601Serializer
end

class ActiveSupport::EncryptedFile
  CIPHER = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::EventedFileUpdateChecker
  def execute(); end

  def execute_if_updated(); end

  def initialize(files, dirs=T.unsafe(nil), &block); end

  def updated?(); end
end

class ActiveSupport::EventedFileUpdateChecker::PathHelper
  def existing_parent(dir); end

  def filter_out_descendants(dirs); end

  def longest_common_subpath(paths); end

  def normalize_extension(ext); end

  def xpath(path); end
end

class ActiveSupport::EventedFileUpdateChecker::PathHelper
end

class ActiveSupport::EventedFileUpdateChecker
end

class ActiveSupport::ExecutionWrapper
  include ::ActiveSupport::Callbacks
  def __callbacks(); end

  def __callbacks?(); end

  def _complete_callbacks(); end

  def _run_callbacks(); end

  def _run_complete_callbacks(&block); end

  def _run_run_callbacks(&block); end

  def complete!(); end

  def run!(); end
  Null = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::ExecutionWrapper::CompleteHook
  def after(target); end

  def before(target); end

  def hook(); end

  def hook=(_); end
end

class ActiveSupport::ExecutionWrapper::CompleteHook
  def self.[](*_); end

  def self.members(); end
end

class ActiveSupport::ExecutionWrapper::RunHook
  def before(target); end

  def hook(); end

  def hook=(_); end
end

class ActiveSupport::ExecutionWrapper::RunHook
  def self.[](*_); end

  def self.members(); end
end

class ActiveSupport::ExecutionWrapper
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._complete_callbacks(); end

  def self._complete_callbacks=(value); end

  def self._run_callbacks(); end

  def self._run_callbacks=(value); end

  def self.active(); end

  def self.active=(active); end

  def self.active?(); end

  def self.inherited(other); end

  def self.register_hook(hook, outer: T.unsafe(nil)); end

  def self.run!(); end

  def self.to_complete(*args, &block); end

  def self.to_run(*args, &block); end

  def self.wrap(); end
end

class ActiveSupport::Executor
end

class ActiveSupport::Executor
end

module ActiveSupport::Gzip
end

class ActiveSupport::Gzip::Stream
end

class ActiveSupport::Gzip::Stream
end

module ActiveSupport::Gzip
  def self.compress(source, level=T.unsafe(nil), strategy=T.unsafe(nil)); end

  def self.decompress(source); end
end

class ActiveSupport::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def assoc(key); end

  def default(*args); end

  def delete(key); end

  def dig(*args); end

  def fetch(key, *extras); end

  def fetch_values(*indices, &block); end

  def has_key?(key); end

  def include?(key); end

  def initialize(constructor=T.unsafe(nil)); end

  def key?(key); end

  def member?(key); end

  def merge(hash, &block); end

  def merge!(other_hash); end

  def regular_update(_); end

  def regular_writer(_, _1); end

  def reject(*args, &block); end

  def replace(other_hash); end

  def select(*args, &block); end

  def slice(*keys); end

  def store(key, value); end

  def transform_keys(*args, &block); end

  def transform_values(*args, &block); end

  def update(other_hash); end

  def values_at(*indices); end
end

class ActiveSupport::HashWithIndifferentAccess
  def self.[](*args); end
end

module ActiveSupport::JSON
  DATETIME_REGEX = ::T.let(nil, ::T.untyped)
  DATE_REGEX = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::JSON::Encoding
end

class ActiveSupport::JSON::Encoding::JSONGemEncoder
  def encode(value); end

  def initialize(options=T.unsafe(nil)); end

  def options(); end
end

class ActiveSupport::JSON::Encoding::JSONGemEncoder
end

module ActiveSupport::JSON::Encoding
  def self.escape_html_entities_in_json(); end

  def self.escape_html_entities_in_json=(escape_html_entities_in_json); end

  def self.json_encoder(); end

  def self.json_encoder=(json_encoder); end

  def self.time_precision(); end

  def self.time_precision=(time_precision); end

  def self.use_standard_json_time_format(); end

  def self.use_standard_json_time_format=(use_standard_json_time_format); end
end

module ActiveSupport::JSON
  def self.decode(json); end

  def self.encode(value, options=T.unsafe(nil)); end

  def self.parse_error(); end
end

class ActiveSupport::LegacyKeyGenerator
  SECRET_MIN_LENGTH = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::LogSubscriber
  def colorize_logging(); end

  def colorize_logging=(obj); end

  def debug(progname=T.unsafe(nil), &block); end

  def error(progname=T.unsafe(nil), &block); end

  def fatal(progname=T.unsafe(nil), &block); end

  def info(progname=T.unsafe(nil), &block); end

  def logger(); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::LogSubscriber
  def self.colorize_logging(); end

  def self.colorize_logging=(obj); end

  def self.flush_all!(); end

  def self.log_subscribers(); end

  def self.logger(); end

  def self.logger=(logger); end
end

class ActiveSupport::MessageEncryptor
  include ::ActiveSupport::Messages::Rotator::Encryptor
  include ::ActiveSupport::Messages::Rotator
end

ActiveSupport::MessageEncryptor::OpenSSLCipherError = OpenSSL::Cipher::CipherError

class ActiveSupport::MessageVerifier
  include ::ActiveSupport::Messages::Rotator::Verifier
  include ::ActiveSupport::Messages::Rotator
end

class ActiveSupport::Multibyte::Chars
  include ::Comparable
  def =~(*args, &block); end

  def acts_like_string?(*args, &block); end

  def capitalize(); end

  def capitalize!(*args); end

  def compose(); end

  def decompose(); end

  def downcase(); end

  def downcase!(*args); end

  def grapheme_length(); end

  def initialize(string); end

  def limit(limit); end

  def method_missing(method, *args, &block); end

  def normalize(form=T.unsafe(nil)); end

  def reverse(); end

  def reverse!(*args); end

  def slice!(*args); end

  def split(*args); end

  def swapcase(); end

  def tidy_bytes(force=T.unsafe(nil)); end

  def tidy_bytes!(*args); end

  def titlecase(); end

  def titleize(); end

  def to_str(); end

  def upcase(); end

  def upcase!(*args); end

  def wrapped_string(); end
end

class ActiveSupport::Multibyte::Chars
  def self.consumes?(string); end
end

module ActiveSupport::Multibyte::Unicode
  def compose(codepoints); end

  def decompose(type, codepoints); end

  def default_normalization_form(); end

  def default_normalization_form=(default_normalization_form); end

  def downcase(string); end

  def in_char_class?(codepoint, classes); end

  def normalize(string, form=T.unsafe(nil)); end

  def pack_graphemes(unpacked); end

  def reorder_characters(codepoints); end

  def swapcase(string); end

  def tidy_bytes(string, force=T.unsafe(nil)); end

  def unpack_graphemes(string); end

  def upcase(string); end
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SLAST = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
  NORMALIZATION_FORMS = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Multibyte::Unicode::Codepoint
  def code(); end

  def code=(code); end

  def combining_class(); end

  def combining_class=(combining_class); end

  def decomp_mapping(); end

  def decomp_mapping=(decomp_mapping); end

  def decomp_type(); end

  def decomp_type=(decomp_type); end

  def lowercase_mapping(); end

  def lowercase_mapping=(lowercase_mapping); end

  def swapcase_mapping(); end

  def uppercase_mapping(); end

  def uppercase_mapping=(uppercase_mapping); end
end

class ActiveSupport::Multibyte::Unicode::Codepoint
end

class ActiveSupport::Multibyte::Unicode::UnicodeDatabase
  def boundary(); end

  def boundary=(boundary); end

  def codepoints(); end

  def codepoints=(codepoints); end

  def composition_exclusion(); end

  def composition_exclusion=(composition_exclusion); end

  def composition_map(); end

  def composition_map=(composition_map); end

  def cp1252(); end

  def cp1252=(cp1252); end

  def load(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Multibyte::Unicode::UnicodeDatabase
  def self.dirname(); end

  def self.filename(); end
end

module ActiveSupport::Multibyte::Unicode
  extend ::ActiveSupport::Multibyte::Unicode
end

class ActiveSupport::NumberHelper::NumberConverter
  def execute(); end

  def initialize(number, options); end

  def namespace(); end

  def namespace=(val); end

  def namespace?(); end

  def number(); end

  def opts(); end

  def validate_float(); end

  def validate_float=(val); end

  def validate_float?(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberConverter
  def self.convert(number, options); end

  def self.namespace(); end

  def self.namespace=(val); end

  def self.namespace?(); end

  def self.validate_float(); end

  def self.validate_float=(val); end

  def self.validate_float?(); end
end

class ActiveSupport::NumberHelper::NumberToCurrencyConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToCurrencyConverter
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter
  def convert(); end
  DEFAULT_DELIMITER_REGEX = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter
end

class ActiveSupport::NumberHelper::NumberToHumanConverter
  def convert(); end
  DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
  INVERTED_DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanConverter
end

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter
  def convert(); end
  STORAGE_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter
end

class ActiveSupport::NumberHelper::NumberToPercentageConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToPercentageConverter
end

class ActiveSupport::NumberHelper::NumberToPhoneConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToPhoneConverter
end

class ActiveSupport::NumberHelper::NumberToRoundedConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToRoundedConverter
end

class ActiveSupport::NumberHelper::RoundingHelper
  def digit_count(number); end

  def initialize(options); end

  def options(); end

  def round(number); end
end

class ActiveSupport::NumberHelper::RoundingHelper
end

module ActiveSupport::NumberHelper
  extend ::ActiveSupport::Autoload
  extend ::ActiveSupport::NumberHelper
end

class ActiveSupport::OrderedHash
  def encode_with(coder); end

  def reject(*args, &block); end

  def select(*args, &block); end

  def to_yaml_type(); end
end

class ActiveSupport::OrderedHash
end

class ActiveSupport::ProxyObject
  def raise(*args); end
end

class ActiveSupport::ProxyObject
end

class ActiveSupport::Reloader
  def _class_unload_callbacks(); end

  def _prepare_callbacks(); end

  def _run_class_unload_callbacks(&block); end

  def _run_prepare_callbacks(&block); end

  def check(); end

  def check=(val); end

  def check?(); end

  def class_unload!(&block); end

  def executor(); end

  def executor=(val); end

  def executor?(); end

  def release_unload_lock!(); end

  def require_unload_lock!(); end
end

class ActiveSupport::Reloader
  def self._class_unload_callbacks(); end

  def self._class_unload_callbacks=(value); end

  def self._prepare_callbacks(); end

  def self._prepare_callbacks=(value); end

  def self.after_class_unload(*args, &block); end

  def self.before_class_unload(*args, &block); end

  def self.check(); end

  def self.check!(); end

  def self.check=(val); end

  def self.check?(); end

  def self.executor(); end

  def self.executor=(val); end

  def self.executor?(); end

  def self.prepare!(); end

  def self.reload!(); end

  def self.reloaded!(); end

  def self.to_prepare(*args, &block); end
end

module ActiveSupport::Rescuable
  def handler_for_rescue(exception); end

  def rescue_with_handler(exception); end
end

module ActiveSupport::Rescuable::ClassMethods
  def handler_for_rescue(exception, object: T.unsafe(nil)); end

  def rescue_from(*klasses, with: T.unsafe(nil), &block); end

  def rescue_with_handler(exception, object: T.unsafe(nil), visited_exceptions: T.unsafe(nil)); end
end

module ActiveSupport::Rescuable::ClassMethods
end

module ActiveSupport::Rescuable
  extend ::ActiveSupport::Concern
end

class ActiveSupport::SafeBuffer
  def %(args); end

  def +(other); end

  def <<(value); end

  def [](*args); end

  def capitalize(*args, &block); end

  def capitalize!(*args); end

  def chomp(*args, &block); end

  def chomp!(*args); end

  def chop(*args, &block); end

  def chop!(*args); end

  def clone_empty(); end

  def concat(value); end

  def delete(*args, &block); end

  def delete!(*args); end

  def downcase(*args, &block); end

  def downcase!(*args); end

  def encode_with(coder); end

  def gsub(*args, &block); end

  def gsub!(*args); end

  def initialize(str=T.unsafe(nil)); end

  def lstrip(*args, &block); end

  def lstrip!(*args); end

  def next(*args, &block); end

  def next!(*args); end

  def prepend(value); end

  def reverse(*args, &block); end

  def reverse!(*args); end

  def rstrip(*args, &block); end

  def rstrip!(*args); end

  def safe_concat(value); end

  def slice(*args, &block); end

  def slice!(*args); end

  def squeeze(*args, &block); end

  def squeeze!(*args); end

  def strip(*args, &block); end

  def strip!(*args); end

  def sub(*args, &block); end

  def sub!(*args); end

  def succ(*args, &block); end

  def succ!(*args); end

  def swapcase(*args, &block); end

  def swapcase!(*args); end

  def tr(*args, &block); end

  def tr!(*args); end

  def tr_s(*args, &block); end

  def tr_s!(*args); end

  def upcase(*args, &block); end

  def upcase!(*args); end
  UNSAFE_STRING_METHODS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::SafeBuffer::SafeConcatError
  def initialize(); end
end

class ActiveSupport::SafeBuffer::SafeConcatError
end

class ActiveSupport::SafeBuffer
end

class ActiveSupport::StringInquirer
end

class ActiveSupport::StringInquirer
end

class ActiveSupport::Subscriber
  def finish(name, id, payload); end

  def patterns(); end

  def start(name, id, payload); end
end

class ActiveSupport::Subscriber
  def self.attach_to(namespace, subscriber=T.unsafe(nil), notifier=T.unsafe(nil)); end

  def self.method_added(event); end

  def self.namespace(); end

  def self.notifier(); end

  def self.subscriber(); end

  def self.subscribers(); end
end

class ActiveSupport::SubscriberQueueRegistry
  def get_queue(queue_key); end
end

class ActiveSupport::SubscriberQueueRegistry
  extend ::ActiveSupport::PerThreadRegistry
end

module ActiveSupport::TaggedLogging
  def clear_tags!(*args, &block); end

  def flush(); end

  def pop_tags(*args, &block); end

  def push_tags(*args, &block); end

  def tagged(*tags); end
end

module ActiveSupport::TaggedLogging::Formatter
  def call(severity, timestamp, progname, msg); end

  def clear_tags!(); end

  def current_tags(); end

  def pop_tags(size=T.unsafe(nil)); end

  def push_tags(*tags); end

  def tagged(*tags); end

  def tags_text(); end
end

module ActiveSupport::TaggedLogging::Formatter
end

module ActiveSupport::TaggedLogging
  def self.new(logger); end
end

class ActiveSupport::TestCase
  include ::ActiveSupport::Testing::TaggedLogging
  include ::ActiveSupport::Callbacks
  include ::ActiveSupport::Testing::Assertions
  include ::ActiveSupport::Testing::Deprecation
  include ::ActiveSupport::Testing::TimeHelpers
  include ::ActiveSupport::Testing::FileFixtures
  include ::ActiveSupport::Testing::SetupAndTeardown
  def __callbacks(); end

  def __callbacks?(); end

  def _run_setup_callbacks(&block); end

  def _run_teardown_callbacks(&block); end

  def _setup_callbacks(); end

  def _teardown_callbacks(); end

  def assert_no_match(matcher, obj, msg=T.unsafe(nil)); end

  def assert_not_empty(obj, msg=T.unsafe(nil)); end

  def assert_not_equal(exp, act, msg=T.unsafe(nil)); end

  def assert_not_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_in_epsilon(a, b, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_includes(collection, obj, msg=T.unsafe(nil)); end

  def assert_not_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_not_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_not_nil(obj, msg=T.unsafe(nil)); end

  def assert_not_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_predicate(o1, op, msg=T.unsafe(nil)); end

  def assert_not_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def assert_not_same(exp, act, msg=T.unsafe(nil)); end

  def assert_raise(*exp); end

  def file_fixture_path(); end

  def file_fixture_path?(); end

  def method_name(); end
end

class ActiveSupport::TestCase
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveSupport::Testing::Declarative
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._setup_callbacks(); end

  def self._setup_callbacks=(value); end

  def self._teardown_callbacks(); end

  def self._teardown_callbacks=(value); end

  def self.file_fixture_path(); end

  def self.file_fixture_path=(val); end

  def self.file_fixture_path?(); end

  def self.test_order=(new_order); end
end

module ActiveSupport::Testing
end

module ActiveSupport::Testing::Assertions
  def assert_changes(expression, message=T.unsafe(nil), from: T.unsafe(nil), to: T.unsafe(nil), &block); end

  def assert_difference(expression, *args, &block); end

  def assert_no_changes(expression, message=T.unsafe(nil), &block); end

  def assert_no_difference(expression, message=T.unsafe(nil), &block); end

  def assert_not(object, message=T.unsafe(nil)); end

  def assert_nothing_raised(); end
  UNTRACKED = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Testing::Assertions
end

module ActiveSupport::Testing::ConstantLookup
end

module ActiveSupport::Testing::ConstantLookup::ClassMethods
  def determine_constant_from_test_name(test_name); end
end

module ActiveSupport::Testing::ConstantLookup::ClassMethods
end

module ActiveSupport::Testing::ConstantLookup
  extend ::ActiveSupport::Concern
end

module ActiveSupport::Testing::Declarative
  def test(name, &block); end
end

module ActiveSupport::Testing::Declarative
end

module ActiveSupport::Testing::Deprecation
  def assert_deprecated(match=T.unsafe(nil), deprecator=T.unsafe(nil), &block); end

  def assert_not_deprecated(deprecator=T.unsafe(nil), &block); end

  def collect_deprecations(deprecator=T.unsafe(nil)); end
end

module ActiveSupport::Testing::Deprecation
end

module ActiveSupport::Testing::FileFixtures
  def file_fixture(fixture_name); end
end

module ActiveSupport::Testing::FileFixtures
  extend ::ActiveSupport::Concern
end

module ActiveSupport::Testing::Isolation
  include ::ActiveSupport::Testing::Isolation::Forking
  def run(); end
end

module ActiveSupport::Testing::Isolation::Forking
  def run_in_isolation(&blk); end
end

module ActiveSupport::Testing::Isolation::Forking
end

module ActiveSupport::Testing::Isolation::Subprocess
  def run_in_isolation(&blk); end
  ORIG_ARGV = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Testing::Isolation::Subprocess
end

module ActiveSupport::Testing::Isolation
  def self.forking_env?(); end

  def self.included(klass); end
end

module ActiveSupport::Testing::SetupAndTeardown
  def after_teardown(); end

  def before_setup(); end
end

module ActiveSupport::Testing::SetupAndTeardown
  def self.prepended(klass); end
end

class ActiveSupport::Testing::SimpleStubs
  def stub_object(object, method_name, &block); end

  def stubbing(object, method_name); end

  def unstub_all!(); end
end

class ActiveSupport::Testing::SimpleStubs::Stub
  def method_name(); end

  def method_name=(_); end

  def object(); end

  def object=(_); end

  def original_method(); end

  def original_method=(_); end
end

class ActiveSupport::Testing::SimpleStubs::Stub
  def self.[](*_); end

  def self.members(); end
end

class ActiveSupport::Testing::SimpleStubs
end

module ActiveSupport::Testing::TaggedLogging
  def before_setup(); end

  def tagged_logger=(tagged_logger); end
end

module ActiveSupport::Testing::TaggedLogging
end

module ActiveSupport::Testing::TimeHelpers
  def after_teardown(); end

  def freeze_time(&block); end

  def travel(duration, &block); end

  def travel_back(); end

  def travel_to(date_or_time); end
end

module ActiveSupport::Testing::TimeHelpers
end

module ActiveSupport::Testing
end

class ActiveSupport::TimeWithZone
  include ::DateAndTime::Compatibility
  PRECISIONS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::TimeZone
  MAPPING = ::T.let(nil, ::T.untyped)
  UTC_OFFSET_WITHOUT_COLON = ::T.let(nil, ::T.untyped)
  UTC_OFFSET_WITH_COLON = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::XMLConverter
  DISALLOWED_TYPES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini
  DEFAULT_ENCODINGS = ::T.let(nil, ::T.untyped)
  FORMATTING = ::T.let(nil, ::T.untyped)
  PARSING = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini_REXML
  CONTENT_KEY = ::T.let(nil, ::T.untyped)
end

module ActiveSupport
  def self.escape_html_entities_in_json(*args, &block); end

  def self.escape_html_entities_in_json=(arg); end

  def self.json_encoder(*args, &block); end

  def self.json_encoder=(arg); end

  def self.parse_json_times(); end

  def self.parse_json_times=(obj); end

  def self.time_precision(*args, &block); end

  def self.time_precision=(arg); end

  def self.use_standard_json_time_format(*args, &block); end

  def self.use_standard_json_time_format=(arg); end
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def bsearch(); end

  def bsearch_index(); end

  def collect!(); end

  def dig(*_); end

  def flatten!(*_); end

  def pack(*_); end

  def replace(_); end

  def shelljoin(); end

  def to_h(); end

end

class Array
  def self.try_convert(_); end
end

BasicObject::BasicObject = BasicObject

class BasicSocket
  def read_nonblock(len, str=T.unsafe(nil), exception: T.unsafe(nil)); end
end

class BigDecimal
  include ::ActiveSupport::BigDecimalWithDefaultFormat
  def clone(); end

  def to_d(); end

  def to_digits(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  SIGN_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.ver(); end
end

class Binding
  def clone(); end

  def irb(); end
end

class Bundler::CurrentRuby
  def jruby_27?(); end

  def maglev_27?(); end

  def mingw_27?(); end

  def mri_27?(); end

  def mswin64_27?(); end

  def mswin_27?(); end

  def on_27?(); end

  def rbx_27?(); end

  def ruby_27?(); end

  def truffleruby_27?(); end

  def x64_mingw_27?(); end
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::FeatureFlag
  def github_https?(); end

  def lockfile_upgrade_warning?(); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::AuthenticationRequiredError
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CertificateFailureError
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::FallbackError
end

class Bundler::Fetcher::FallbackError
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::NetworkDownError
end

class Bundler::Fetcher::NetworkDownError
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::SSLError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end
end

class Bundler::GemHelper
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_input(cmd); end

  def sh_with_status(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::Molinillo::DependencyGraph
  include ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

class Bundler::Plugin::DSL
  def _gem(name, *args); end

  def inferred_plugins(); end

  def plugin(name, *args); end
end

class Bundler::Plugin::DSL::PluginGemfileError
end

class Bundler::Plugin::DSL::PluginGemfileError
end

class Bundler::Plugin::DSL
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

module Bundler::Plugin::Events
  def self.defined_event?(event); end
end

class Bundler::Plugin::Index
  def command_plugin(command); end

  def commands(); end

  def global_index_file(); end

  def hook_plugins(event); end

  def index_file(); end

  def installed?(name); end

  def load_paths(name); end

  def local_index_file(); end

  def plugin_path(name); end

  def register_plugin(name, path, load_paths, commands, sources, hooks); end

  def source?(source); end

  def source_plugin(name); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Index
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubygemsIntegration::MoreFuture
  def default_stubs(); end
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::SpecSet
  include ::Enumerable
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

class Class
  def descendants(); end

  def json_creatable?(); end

  def subclasses(); end
end

class Complex
  def self.polar(*_); end

  def self.rect(*_); end

  def self.rectangular(*_); end
end

module Concurrent
  AtExit = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  NULL_LOGGER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExecutorService
  FALLBACK_POLICIES = ::T.let(nil, ::T.untyped)
end

Concurrent::Collection::MapImplementation = Concurrent::Collection::MriMapBackend

class Concurrent::ConcurrentUpdateError
  CONC_UP_ERR_BACKTRACE = ::T.let(nil, ::T.untyped)
end

class Concurrent::LockFreeStack
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Concurrent::MVar
  EMPTY = ::T.let(nil, ::T.untyped)
  TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::Maybe
  NONE = ::T.let(nil, ::T.untyped)
end

module Concurrent::Promises::InternalStates
  PENDING = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  RESOLVED = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReadWriteLock
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReentrantReadWriteLock
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  READER_BITS = ::T.let(nil, ::T.untyped)
  READ_LOCK_MASK = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
  WRITER_BITS = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_HELD = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_MASK = ::T.let(nil, ::T.untyped)
end

class Concurrent::RubyThreadPoolExecutor
  DEFAULT_MAX_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_QUEUE_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MIN_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_THREAD_IDLETIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::SerializedExecutionDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

Concurrent::Synchronization::Volatile = Concurrent::Synchronization::MriAttrVolatile

class Concurrent::SynchronizedDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Concurrent::ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

class Concurrent::TimerTask
  EXECUTION_INTERVAL = ::T.let(nil, ::T.untyped)
  TIMEOUT_INTERVAL = ::T.let(nil, ::T.untyped)
end

class Concurrent::Transaction
  ABORTED = ::T.let(nil, ::T.untyped)
end

module Concurrent::Utility::NativeInteger
  MAX_VALUE = ::T.let(nil, ::T.untyped)
  MIN_VALUE = ::T.let(nil, ::T.untyped)
end

class Date
  DATE_FORMATS = ::T.let(nil, ::T.untyped)
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

module DateAndTime::Calculations
  DAYS_INTO_WEEK = ::T.let(nil, ::T.untyped)
  WEEKEND_DAYS = ::T.let(nil, ::T.untyped)
end

class Delegator
  def !=(obj); end

  def ==(obj); end

  def __getobj__(); end

  def __setobj__(obj); end

  def eql?(obj); end

  def initialize(obj); end

  def marshal_dump(); end

  def marshal_load(data); end

  def method_missing(m, *args, &block); end

  def methods(all=T.unsafe(nil)); end

  def protected_methods(all=T.unsafe(nil)); end

  def public_methods(all=T.unsafe(nil)); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Delegator
  def self.const_missing(n); end

  def self.delegating_block(mid); end

  def self.public_api(); end
end

class Dir
  def self.children(*_); end

  def self.each_child(*_); end

  def self.empty?(_); end

  def self.exists?(_); end

  def self.tmpdir(); end
end

module ERB::Util
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_ONCE_REGEXP = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE_REGEXP = ::T.let(nil, ::T.untyped)
end

module ERB::Util
  def self.html_escape_once(s); end

  def self.json_escape(s); end

  def self.unwrapped_html_escape(s); end
end

Emitter = Psych::Stream::Emitter

class Encoding
  def _dump(*_); end
end

class Encoding::Converter
  def convert(_); end

  def convpath(); end

  def destination_encoding(); end

  def finish(); end

  def initialize(*_); end

  def insert_output(_); end

  def last_error(); end

  def primitive_convert(*_); end

  def primitive_errinfo(); end

  def putback(*_); end

  def replacement(); end

  def replacement=(replacement); end

  def source_encoding(); end
end

class Encoding::Converter
  def self.asciicompat_encoding(_); end

  def self.search_convpath(*_); end
end

class Encoding::InvalidByteSequenceError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_bytes(); end

  def incomplete_input?(); end

  def readagain_bytes(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding::UndefinedConversionError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_char(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding
  def self._load(_); end

  def self.locale_charmap(); end
end

module Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def chunk(); end

  def chunk_while(); end

  def each_entry(*_); end

  def exclude?(object); end

  def grep_v(_); end

  def index_by(); end

  def many?(); end

  def pluck(*keys); end

  def slice_after(*_); end

  def slice_before(*_); end

  def slice_when(); end

  def sum(identity=T.unsafe(nil), &block); end

  def to_set(klass=T.unsafe(nil), *args, &block); end

  def uniq(); end

  def without(*elements); end

  def zip(*_); end
end

class Enumerator
  def each_with_index(); end
end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

class Enumerator::Lazy
  def chunk(*_); end

  def chunk_while(*_); end

  def force(*_); end

  def slice_when(*_); end
end

Errno::EAUTH = Errno::NOERROR

Errno::EBADRPC = Errno::NOERROR

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::EDEADLK

Errno::EDOOFUS = Errno::NOERROR

Errno::EFTYPE = Errno::NOERROR

Errno::EIPSEC = Errno::NOERROR

Errno::ENEEDAUTH = Errno::NOERROR

Errno::ENOATTR = Errno::NOERROR

Errno::ENOTCAPABLE = Errno::NOERROR

Errno::ENOTSUP = Errno::EOPNOTSUPP

Errno::EPROCLIM = Errno::NOERROR

Errno::EPROCUNAVAIL = Errno::NOERROR

Errno::EPROGMISMATCH = Errno::NOERROR

Errno::EPROGUNAVAIL = Errno::NOERROR

Errno::ERPCMISMATCH = Errno::NOERROR

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def dir=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Exception
  include ::ActiveSupport::Dependencies::Blamable
  def full_message(*_); end
end

class Exception
  def self.exception(*_); end

  def self.to_tty?(); end
end

class ExitCalledError
end

class ExitCalledError
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

class Fiber
  def resume(*_); end

  def transfer(*_); end
end

class Fiber
  def self.current(); end

  def self.yield(*_); end
end

class File
  Separator = ::T.let(nil, ::T.untyped)
end

class File::Stat
  def size?(); end
end

class File
  def self.atomic_write(file_name, temp_dir=T.unsafe(nil)); end

  def self.empty?(_); end

  def self.exists?(_); end

  def self.lutime(*_); end

  def self.mkfifo(*_); end

  def self.probe_stat_in(dir); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
  def to_d(precision=T.unsafe(nil)); end
end

module GC
  def garbage_collect(*_); end
end

module GC
  def self.latest_gc_info(*_); end

  def self.stress=(stress); end

  def self.verify_internal_consistency(); end
end

class Gem::DependencyInstaller
  def _deprecated_gems_to_install(); end

  def gems_to_install(*args, &block); end
end

class Gem::Resolver
end

Gem::DependencyResolver::Conflict = Gem::Resolver::Conflict

Gem::DependencyResolver::DependencyConflict = Gem::Resolver::Conflict

module Gem::Resolver::Molinillo
end

Gem::DependencyResolver::Molinillo::SpecificationProvider = Gem::Resolver::Molinillo::SpecificationProvider

Gem::DependencyResolver::Molinillo::UI = Gem::Resolver::Molinillo::UI

module Gem::Resolver::Molinillo
end

class Gem::Resolver
end

class Gem::Licenses
  IDENTIFIERS = ::T.let(nil, ::T.untyped)
end

class Gem::Package
  def realpath(file); end
end

class Gem::RemoteFetcher
  def api_endpoint(uri); end
end

Gem::RequestSet::GemDepedencyAPI = Gem::RequestSet::GemDependencyAPI

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::Source
  def api_uri(); end
end

class Gem::Specification
  def bundled_gem_in_old_ruby?(); end

  def rubyforge_project(); end

  def warning(statement); end
end

class Gem::Specification
  extend ::Enumerable
end

module Gem::Util
  NULL_DEVICE = ::T.let(nil, ::T.untyped)
end

module Gem
  def self._deprecated_datadir(gem_name); end

end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def <(_); end

  def <=(_); end

  def >(_); end

  def >=(_); end

  def compact(); end

  def compact!(); end

  def default_proc(); end

  def default_proc=(default_proc); end

  def fetch_values(*_); end

  def flatten(*_); end

  def index(_); end

  def nested_under_indifferent_access(); end

  def replace(_); end

  def slice(*_); end

  def to_h(); end

  def to_proc(); end

  def transform_keys(); end

  def transform_keys!(); end

  def transform_values(); end

  def transform_values!(); end

  def update(_); end

  def with_indifferent_access(); end
end

class Hash
  def self.try_convert(_); end
end

module I18n
  DEFAULT_INTERPOLATION_PATTERNS = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  INTERPOLATION_PATTERN = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS_PATTERN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module I18n::Backend
end

module I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def deep_interpolate(locale, data, values=T.unsafe(nil)); end

  def default(locale, object, subject, options=T.unsafe(nil)); end

  def eager_load!(); end

  def eager_loaded?(); end

  def exists?(locale, key); end

  def interpolate(locale, subject, values=T.unsafe(nil)); end

  def load_file(filename); end

  def load_json(filename); end

  def load_rb(filename); end

  def load_translations(*filenames); end

  def load_yaml(filename); end

  def load_yml(filename); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralization_key(entry, count); end

  def pluralize(locale, entry, count); end

  def reload!(); end

  def resolve(locale, object, subject, options=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def translate_localization_format(locale, object, format, options); end
end

module I18n::Backend::Base
end

module I18n::Backend::Cache
  def _fetch(cache_key, &block); end

  def cache_key(locale, key, options); end

  def fetch(cache_key, &block); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Cache
end

module I18n::Backend::CacheFile
  def load_file(filename); end

  def normalized_path(file); end

  def path_roots(); end

  def path_roots=(path_roots); end
end

module I18n::Backend::CacheFile
end

module I18n::Backend::Cascade
  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end
end

module I18n::Backend::Cascade
end

module I18n::Backend::Fallbacks
  def exists?(locale, key); end

  def extract_non_symbol_default!(options); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Fallbacks
end

module I18n::Backend::Flatten
  def escape_default_separator(key); end

  def find_link(locale, key); end

  def flatten_keys(hash, escape, prev_key=T.unsafe(nil), &block); end

  def flatten_translations(locale, data, escape, subtree); end

  def links(); end

  def normalize_flat_keys(locale, key, scope, separator); end

  def resolve_link(locale, key); end

  def store_link(locale, key, link); end
  FLATTEN_SEPARATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR_ESCAPE_CHAR = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Flatten
  def self.escape_default_separator(key); end

  def self.normalize_flat_keys(locale, key, scope, separator); end
end

module I18n::Backend::Gettext
  def load_po(filename); end

  def normalize(locale, data); end

  def normalize_pluralization(locale, key, value); end

  def parse(filename); end
end

class I18n::Backend::Gettext::PoData
  def set_comment(msgid_or_sym, comment); end
end

class I18n::Backend::Gettext::PoData
end

module I18n::Backend::Gettext
end

module I18n::Backend::InterpolationCompiler
  def compile_all_strings_in(data); end

  def interpolate(locale, string, values); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::InterpolationCompiler::Compiler
  def compile_if_an_interpolation(string); end

  def compile_interpolation_token(key); end

  def compiled_interpolation_body(str); end

  def direct_key(key); end

  def escape_key_sym(key); end

  def escape_plain_str(str); end

  def handle_interpolation_token(interpolation, matchdata); end

  def interpolate_key(key); end

  def interpolate_or_raise_missing(key); end

  def interpolated_str?(str); end

  def missing_key(key); end

  def nil_key(key); end

  def reserved_key(key); end

  def tokenize(str); end
  INTERPOLATION_SYNTAX_PATTERN = ::T.let(nil, ::T.untyped)
  TOKENIZER = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::InterpolationCompiler::Compiler
  extend ::I18n::Backend::InterpolationCompiler::Compiler
end

module I18n::Backend::InterpolationCompiler
end

class I18n::Backend::KeyValue
  include ::I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def init_translations(); end

  def initialize(store, subtrees=T.unsafe(nil)); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def store(); end

  def store=(store); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translations(); end
end

module I18n::Backend::KeyValue::Implementation
end

class I18n::Backend::KeyValue::SubtreeProxy
  def [](key); end

  def has_key?(key); end

  def initialize(master_key, store); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end
end

class I18n::Backend::KeyValue::SubtreeProxy
end

class I18n::Backend::KeyValue
end

module I18n::Backend::Memoize
  def available_locales(); end

  def eager_load!(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def memoized_lookup(); end

  def reload!(); end

  def reset_memoizations!(locale=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::Memoize
end

module I18n::Backend::Metadata
  def interpolate(locale, entry, values=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def with_metadata(metadata, &block); end
end

module I18n::Backend::Metadata
  def self.included(base); end
end

module I18n::Backend::Pluralization
  def pluralize(locale, entry, count); end

  def pluralizer(locale); end

  def pluralizers(); end
end

module I18n::Backend::Pluralization
end

class I18n::Backend::Simple
  include ::I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def eager_load!(); end

  def init_translations(); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translations(do_init: T.unsafe(nil)); end
end

module I18n::Backend::Simple::Implementation
end

class I18n::Backend::Simple
end

module I18n::Backend::Transliterator
  def transliterate(locale, string, replacement=T.unsafe(nil)); end
  DEFAULT_REPLACEMENT_CHAR = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
  def initialize(rule=T.unsafe(nil)); end

  def transliterate(string, replacement=T.unsafe(nil)); end
  DEFAULT_APPROXIMATIONS = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
end

class I18n::Backend::Transliterator::ProcTransliterator
  def initialize(rule); end

  def transliterate(string, replacement=T.unsafe(nil)); end
end

class I18n::Backend::Transliterator::ProcTransliterator
end

module I18n::Backend::Transliterator
  def self.get(rule=T.unsafe(nil)); end
end

module I18n::Backend
end

module I18n::Gettext
  CONTEXT_SEPARATOR = ::T.let(nil, ::T.untyped)
  PLURAL_SEPARATOR = ::T.let(nil, ::T.untyped)
end

module I18n::Gettext::Helpers
  def N_(msgsid); end

  def _(msgid, options=T.unsafe(nil)); end

  def gettext(msgid, options=T.unsafe(nil)); end

  def n_(msgid, msgid_plural, n=T.unsafe(nil)); end

  def ngettext(msgid, msgid_plural, n=T.unsafe(nil)); end

  def np_(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def npgettext(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def ns_(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def nsgettext(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def p_(msgctxt, msgid); end

  def pgettext(msgctxt, msgid); end

  def s_(msgid, separator=T.unsafe(nil)); end

  def sgettext(msgid, separator=T.unsafe(nil)); end
end

module I18n::Gettext::Helpers
end

module I18n::Gettext
  def self.extract_scope(msgid, separator); end

  def self.plural_keys(*args); end
end

module I18n::Locale
end

class I18n::Locale::Fallbacks
  def [](locale); end

  def compute(tags, include_defaults=T.unsafe(nil), exclude=T.unsafe(nil)); end

  def defaults(); end

  def defaults=(defaults); end

  def initialize(*mappings); end

  def map(mappings); end
end

class I18n::Locale::Fallbacks
end

module I18n::Locale::Tag
  RFC4646_FORMATS = ::T.let(nil, ::T.untyped)
  RFC4646_SUBTAGS = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Parents
  def parent(); end

  def parents(); end

  def self_and_parents(); end
end

module I18n::Locale::Tag::Parents
end

class I18n::Locale::Tag::Rfc4646
  include ::I18n::Locale::Tag::Parents
  def to_sym(); end
end

module I18n::Locale::Tag::Rfc4646::Parser
  PATTERN = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Rfc4646::Parser
  def self.match(tag); end
end

class I18n::Locale::Tag::Rfc4646
  def self.parser(); end

  def self.parser=(parser); end

  def self.tag(tag); end
end

class I18n::Locale::Tag::Simple
  include ::I18n::Locale::Tag::Parents
  def initialize(*tag); end

  def subtags(); end

  def tag(); end

  def to_a(); end

  def to_sym(); end
end

class I18n::Locale::Tag::Simple
  def self.tag(tag); end
end

module I18n::Locale::Tag
  def self.implementation(); end

  def self.implementation=(implementation); end

  def self.tag(tag); end
end

module I18n::Locale
end

class I18n::Middleware
  def call(env); end

  def initialize(app); end
end

class I18n::Middleware
end

module I18n::Tests
end

module I18n::Tests::Localization
end

module I18n::Tests::Localization
  def self.included(base); end
end

module I18n::Tests
end

module I18n
  def self.cache_key_digest(); end

  def self.cache_key_digest=(key_digest); end

  def self.cache_namespace(); end

  def self.cache_namespace=(namespace); end

  def self.cache_store(); end

  def self.cache_store=(store); end

  def self.fallbacks(); end

  def self.fallbacks=(fallbacks); end

  def self.perform_caching?(); end
end

class IO
  def external_encoding(); end

  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def pathconf(_); end

  def pread(*_); end

  def pwrite(_, _1); end

  def ready?(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def write_nonblock(buf, exception: T.unsafe(nil)); end
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.foreach(*_); end
end

class IPAddr
  include ::Comparable
  def &(other); end

  def <<(num); end

  def ==(other); end

  def ===(other); end

  def >>(num); end

  def eql?(other); end

  def family(); end

  def hton(); end

  def include?(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end

  def ip6_arpa(); end

  def ip6_int(); end

  def ipv4?(); end

  def ipv4_compat(); end

  def ipv4_compat?(); end

  def ipv4_mapped(); end

  def ipv4_mapped?(); end

  def ipv6?(); end

  def link_local?(); end

  def loopback?(); end

  def mask(prefixlen); end

  def mask!(mask); end

  def native(); end

  def prefix(); end

  def prefix=(prefix); end

  def private?(); end

  def reverse(); end

  def set(addr, *family); end

  def succ(); end

  def to_i(); end

  def to_range(); end

  def to_string(); end

  def |(other); end

  def ~(); end
  IN4MASK = ::T.let(nil, ::T.untyped)
  IN6FORMAT = ::T.let(nil, ::T.untyped)
  IN6MASK = ::T.let(nil, ::T.untyped)
  RE_IPV4ADDRLIKE = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_COMPRESSED = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_FULL = ::T.let(nil, ::T.untyped)
end

class IPAddr::AddressFamilyError
end

class IPAddr::AddressFamilyError
end

class IPAddr::Error
end

class IPAddr::Error
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidPrefixError
end

class IPAddr::InvalidPrefixError
end

class IPAddr
  def self.new_ntoh(addr); end

  def self.ntop(addr); end
end

module ITypeAssert
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def allbits?(_); end

  def anybits?(_); end

  def digits(*_); end

  def nobits?(_); end

  def pow(*_); end

  def to_bn(); end

  def to_d(); end
end

class Integer
  def self.sqrt(_); end
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

JSONTree = Psych::Visitors::JSONTree

module Kernel
  def gem(dep, *reqs); end

  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def respond_to?(*_); end

  def yield_self(); end
end

module Kernel
  def self.at_exit(); end

  def self.load(*_); end

  def self.require(_); end
end

class KeyError
  def key(); end

  def receiver(); end
end

class LoadError
  def is_missing?(location); end

  def path(); end
end

class LocalJumpError
  def exit_value(); end

  def reason(); end
end

class Logger
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

class Loofah::Scrubber
  def append_attribute(node, attribute, value); end

  def block(); end

  def direction(); end

  def initialize(options=T.unsafe(nil), &block); end

  def scrub(node); end

  def traverse(node); end
  CONTINUE = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class Loofah::Scrubber
end

module Marshal
  def self.restore(*_); end
end

Methods = T::Private::Methods

module Mime
  ALL = ::T.let(nil, ::T.untyped)
  EXTENSION_LOOKUP = ::T.let(nil, ::T.untyped)
  LOOKUP = ::T.let(nil, ::T.untyped)
  SET = ::T.let(nil, ::T.untyped)
end

class Mime::AllType
  include ::Singleton
  def initialize(); end
end

class Mime::AllType
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Mime::Mimes
  include ::Enumerable
  def <<(type); end

  def delete_if(); end

  def each(&blk); end

  def symbols(); end
end

class Mime::Mimes
end

class Mime::NullType
  include ::Singleton
  def ref(); end
end

class Mime::NullType
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Mime::Type
  def ==(mime_type); end

  def ===(list); end

  def =~(mime_type); end

  def all?(); end

  def eql?(other); end

  def html?(); end

  def initialize(string, symbol=T.unsafe(nil), synonyms=T.unsafe(nil)); end

  def ref(); end

  def string(); end

  def symbol(); end

  def synonyms(); end

  def to_str(); end

  def to_sym(); end
end

class Mime::Type::AcceptItem
  def index(); end

  def index=(index); end

  def initialize(index, name, q=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def q(); end

  def q=(q); end
end

class Mime::Type::AcceptItem
end

class Mime::Type::AcceptList
end

class Mime::Type::AcceptList
  def self.find_item_by_name(array, name); end

  def self.sort!(list); end
end

class Mime::Type
  def self.lookup(string); end

  def self.lookup_by_extension(extension); end

  def self.parse(accept_header); end

  def self.parse_data_with_trailing_star(type); end

  def self.parse_trailing_star(accept_header); end

  def self.register(string, symbol, mime_type_synonyms=T.unsafe(nil), extension_synonyms=T.unsafe(nil), skip_lookup=T.unsafe(nil)); end

  def self.register_alias(string, symbol, extension_synonyms=T.unsafe(nil)); end

  def self.register_callback(&block); end

  def self.unregister(symbol); end
end

module Mime
  def self.[](type); end

  def self.fetch(type); end
end

module Minitest::Assertions
  def _synchronize(); end

  def assert_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_in_epsilon(exp, act, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_match(matcher, obj, msg=T.unsafe(nil)); end

  def assert_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_output(stdout=T.unsafe(nil), stderr=T.unsafe(nil)); end

  def assert_path_exists(path, msg=T.unsafe(nil)); end

  def assert_predicate(o1, op, msg=T.unsafe(nil)); end

  def assert_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def assert_same(exp, act, msg=T.unsafe(nil)); end

  def assert_send(send_ary, m=T.unsafe(nil)); end

  def assert_silent(); end

  def assert_throws(sym, msg=T.unsafe(nil)); end

  def capture_io(); end

  def capture_subprocess_io(); end

  def diff(exp, act); end

  def exception_details(e, msg); end

  def fail_after(y, m, d, msg); end

  def flunk(msg=T.unsafe(nil)); end

  def message(msg=T.unsafe(nil), ending=T.unsafe(nil), &default); end

  def mu_pp(obj); end

  def mu_pp_for_diff(obj); end

  def pass(_msg=T.unsafe(nil)); end

  def refute_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_in_epsilon(a, b, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def refute_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def refute_match(matcher, obj, msg=T.unsafe(nil)); end

  def refute_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_path_exists(path, msg=T.unsafe(nil)); end

  def refute_predicate(o1, op, msg=T.unsafe(nil)); end

  def refute_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def refute_same(exp, act, msg=T.unsafe(nil)); end

  def skip(msg=T.unsafe(nil), bt=T.unsafe(nil)); end

  def skip_until(y, m, d, msg); end

  def skipped?(); end

  def things_to_diff(exp, act); end
  E = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

module Minitest::Assertions
  def self.diff(); end

  def self.diff=(o); end
end

module Minitest::Guard
  def jruby?(platform=T.unsafe(nil)); end

  def maglev?(platform=T.unsafe(nil)); end

  def mri?(platform=T.unsafe(nil)); end

  def osx?(platform=T.unsafe(nil)); end

  def rubinius?(platform=T.unsafe(nil)); end

  def windows?(platform=T.unsafe(nil)); end
end

module Minitest::Guard
end

module Minitest::Reportable
  def class_name(); end

  def error?(); end

  def location(); end

  def passed?(); end

  def result_code(); end

  def skipped?(); end
end

module Minitest::Reportable
end

class Minitest::Runnable
  def assertions(); end

  def assertions=(assertions); end

  def failure(); end

  def failures(); end

  def failures=(failures); end

  def initialize(name); end

  def marshal_dump(); end

  def marshal_load(ary); end

  def name(); end

  def name=(o); end

  def passed?(); end

  def result_code(); end

  def run(); end

  def skipped?(); end

  def time(); end

  def time=(time); end

  def time_it(); end
  SIGNALS = ::T.let(nil, ::T.untyped)
end

class Minitest::Runnable
  def self.inherited(klass); end

  def self.methods_matching(re); end

  def self.on_signal(name, action); end

  def self.reset(); end

  def self.run(reporter, options=T.unsafe(nil)); end

  def self.run_one_method(klass, method_name, reporter); end

  def self.runnable_methods(); end

  def self.runnables(); end

  def self.with_info_handler(reporter, &block); end
end

class Minitest::Test
  include ::Minitest::Reportable
  include ::Minitest::Test::LifecycleHooks
  include ::Minitest::Guard
  def capture_exceptions(); end

  def with_info_handler(&block); end
  PASSTHROUGH_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  TEARDOWN_METHODS = ::T.let(nil, ::T.untyped)
end

module Minitest::Test::LifecycleHooks
  def after_setup(); end

  def after_teardown(); end

  def before_setup(); end

  def before_teardown(); end

  def setup(); end

  def teardown(); end
end

module Minitest::Test::LifecycleHooks
end

class Minitest::Test
  extend ::Minitest::Guard
  def self.i_suck_and_my_tests_are_order_dependent!(); end

  def self.io_lock(); end

  def self.io_lock=(io_lock); end

  def self.make_my_diffs_pretty!(); end

  def self.parallelize_me!(); end

  def self.test_order(); end
end

class Module
  include ::Module::Concerning
  include ::ActiveSupport::Dependencies::ModuleConstMissing
  def anonymous?(); end

  def attr_internal(*attrs); end

  def attr_internal_accessor(*attrs); end

  def attr_internal_reader(*attrs); end

  def attr_internal_writer(*attrs); end

  def deprecate_constant(*_); end

  def reachable?(*args, &block); end

  def reachable_with_deprecation?(*args, &block); end

  def reachable_without_deprecation?(); end

  def remove_possible_method(method); end

  def remove_possible_singleton_method(method); end

  def thread_cattr_accessor(*syms); end

  def thread_cattr_reader(*syms); end

  def thread_cattr_writer(*syms); end

  def thread_mattr_accessor(*syms); end

  def thread_mattr_reader(*syms); end

  def thread_mattr_writer(*syms); end

  def undef_method(*_); end
  DELEGATION_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
  DELEGATION_RESERVED_METHOD_NAMES = ::T.let(nil, ::T.untyped)
  RUBY_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
end

module Module::Concerning
  def concern(topic, &module_definition); end

  def concerning(topic, &block); end
end

module Module::Concerning
end

class Module
  def self.attr_internal_naming_format(); end

  def self.attr_internal_naming_format=(attr_internal_naming_format); end

  def self.used_modules(); end
end

class Monitor
  def enter(); end

  def exit(); end

  def try_enter(); end
end

module MonitorMixin
  def initialize(*args); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_mon_enter(); end
end

class MonitorMixin::ConditionVariable
  def broadcast(); end

  def initialize(monitor); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(); end

  def wait_while(); end
end

module MonitorMixin
  def self.extend_object(obj); end
end

class NameError
  def missing_name(); end

  def missing_name?(name); end

  def name(); end

  def receiver(); end
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  def to_i(); end
end

class NoMethodError
  def args(); end

  def private_call?(); end
end

class Numeric
  def byte(); end

  def bytes(); end

  def exabyte(); end

  def exabytes(); end

  def gigabyte(); end

  def gigabytes(); end

  def kilobyte(); end

  def kilobytes(); end

  def megabyte(); end

  def megabytes(); end

  def petabyte(); end

  def petabytes(); end

  def terabyte(); end

  def terabytes(); end
  EXABYTE = ::T.let(nil, ::T.untyped)
  GIGABYTE = ::T.let(nil, ::T.untyped)
  KILOBYTE = ::T.let(nil, ::T.untyped)
  MEGABYTE = ::T.let(nil, ::T.untyped)
  PETABYTE = ::T.let(nil, ::T.untyped)
  TERABYTE = ::T.let(nil, ::T.untyped)
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::PP::ObjectMixin
  include ::ActiveSupport::Dependencies::Loadable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def html_safe?(); end

  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class ObjectSpace::WeakMap
  def [](_); end

  def []=(_, _1); end

  def each(&blk); end

  def each_key(); end

  def each_pair(); end

  def each_value(); end

  def key?(_); end

  def keys(); end

  def length(); end

  def size(); end

  def values(); end
end

module ObjectSpace
  def self.count_objects(*_); end

  def self.define_finalizer(*_); end

  def self.garbage_collect(*_); end

  def self.undefine_finalizer(_); end
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(_); end

  def negative?(); end
end

module OpenSSL::Buffering
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  def self.hkdf(*_); end

  def self.pbkdf2_hmac(*_); end

  def self.scrypt(*_); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def to_octet_string(_); end
end

class OpenSSL::PKey::RSA
  def sign_pss(*_); end

  def verify_pss(*_); end
end

module OpenSSL::SSL
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLContext
  def add_certificate(*_); end

  def alpn_protocols(); end

  def alpn_protocols=(alpn_protocols); end

  def alpn_select_cb(); end

  def alpn_select_cb=(alpn_select_cb); end

  def enable_fallback_scsv(); end

  def max_version=(version); end

  def min_version=(version); end
  DEFAULT_TMP_DH_CALLBACK = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLSocket
  def alpn_protocol(); end

  def tmp_key(); end
end

module OpenSSL::X509
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  def ==(other); end
end

class OpenSSL::X509::CRL
  def ==(other); end
end

class OpenSSL::X509::Extension
  def ==(other); end
end

class OpenSSL::X509::Name
  def to_utf8(); end
end

class OpenSSL::X509::Request
  def ==(other); end
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

module Parlour
  VERSION = ::T.let(nil, ::T.untyped)
end

module Parlour::Debugging
end

module Parlour::Debugging::Tree
  INDENT_SPACES = ::T.let(nil, ::T.untyped)
end

module Parlour::Debugging::Tree
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.begin(*args, &blk); end

  def self.end(*args, &blk); end

  def self.here(*args, &blk); end

  def self.line_prefix(); end

  def self.text_prefix(); end
end

module Parlour::Debugging
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.debug_mode=(*args, &blk); end

  def self.debug_mode?(*args, &blk); end

  def self.debug_puts(*args, &blk); end

  def self.name_for_debug_caller(*args, &blk); end
end

class Parlour::Plugin
  def strictness(*args, &blk); end

  def strictness=(strictness); end
end

class Parlour::RbiGenerator::Attribute
  def class_attribute(*args, &blk); end
end

class Parlour::RbiGenerator::EnumClassNamespace
  def enums(*args, &blk); end
end

class Parlour::RbiGenerator::EnumClassNamespace
end

class Parlour::RbiGenerator::Method
  def final(*args, &blk); end

  def type_parameters(*args, &blk); end
end

class Parlour::RbiGenerator::Namespace
  def create_enum_class(*args, &blk); end

  def create_type_alias(*args, &blk); end

  def final(*args, &blk); end
end

class Parlour::RbiGenerator::Parameter
  PREFIXES = ::T.let(nil, ::T.untyped)
end

class Pathname
  def empty?(); end

  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end
end

class Proc
  def ===(*_); end

  def clone(); end

  def yield(*_); end
end

module Process::Sys
  def self.getegid(); end
end

class Process::Tms
  def cstime(); end

  def cstime=(_); end

  def cutime(); end

  def cutime=(_); end

  def stime(); end

  def stime=(_); end

  def utime(); end

  def utime=(_); end
end

class Process::Tms
  def self.[](*_); end

  def self.members(); end
end

module Process
  def self.last_status(); end

  def self.setpgrp(); end
end

module Psych
  LIBYAML_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Psych::BadAlias
end

class Psych::BadAlias
end

class Psych::ClassLoader
  def big_decimal(); end

  def complex(); end

  def date(); end

  def date_time(); end

  def exception(); end

  def load(klassname); end

  def object(); end

  def psych_omap(); end

  def psych_set(); end

  def range(); end

  def rational(); end

  def regexp(); end

  def struct(); end

  def symbol(); end

  def symbolize(sym); end
  BIG_DECIMAL = ::T.let(nil, ::T.untyped)
  CACHE = ::T.let(nil, ::T.untyped)
  COMPLEX = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  DATE_TIME = ::T.let(nil, ::T.untyped)
  EXCEPTION = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  PSYCH_OMAP = ::T.let(nil, ::T.untyped)
  PSYCH_SET = ::T.let(nil, ::T.untyped)
  RANGE = ::T.let(nil, ::T.untyped)
  RATIONAL = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
end

class Psych::ClassLoader::Restricted
  def initialize(classes, symbols); end
end

class Psych::ClassLoader::Restricted
end

class Psych::ClassLoader
end

class Psych::Coder
  def [](k); end

  def []=(k, v); end

  def add(k, v); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(tag); end

  def map(tag=T.unsafe(nil), style=T.unsafe(nil)); end

  def map=(map); end

  def object(); end

  def object=(object); end

  def represent_map(tag, map); end

  def represent_object(tag, obj); end

  def represent_scalar(tag, value); end

  def represent_seq(tag, list); end

  def scalar(*args); end

  def scalar=(value); end

  def seq(); end

  def seq=(list); end

  def style(); end

  def style=(style); end

  def tag(); end

  def tag=(tag); end

  def type(); end
end

class Psych::Coder
end

class Psych::DisallowedClass
  def initialize(klass_name); end
end

class Psych::DisallowedClass
end

class Psych::Emitter
  def alias(_); end

  def canonical(); end

  def canonical=(canonical); end

  def end_document(_); end

  def indentation(); end

  def indentation=(indentation); end

  def initialize(*_); end

  def line_width(); end

  def line_width=(line_width); end

  def scalar(_, _1, _2, _3, _4, _5); end

  def start_document(_, _1, _2); end

  def start_mapping(_, _1, _2, _3); end

  def start_sequence(_, _1, _2, _3); end

  def start_stream(_); end
end

class Psych::Emitter
end

class Psych::Exception
end

class Psych::Exception
end

class Psych::FALLBACK
  def to_ruby(); end

  def to_ruby=(_); end
end

class Psych::FALLBACK
  def self.[](*_); end

  def self.members(); end
end

class Psych::Handler
  def alias(anchor); end

  def empty(); end

  def end_document(implicit); end

  def end_mapping(); end

  def end_sequence(); end

  def end_stream(); end

  def event_location(start_line, start_column, end_line, end_column); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end

  def start_stream(encoding); end

  def streaming?(); end
  EVENTS = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Psych::Handler::DumperOptions
  def canonical(); end

  def canonical=(canonical); end

  def indentation(); end

  def indentation=(indentation); end

  def line_width(); end

  def line_width=(line_width); end
end

class Psych::Handler::DumperOptions
end

class Psych::Handler
end

module Psych::Handlers
end

class Psych::Handlers::DocumentStream
  def initialize(&block); end
end

class Psych::Handlers::DocumentStream
end

module Psych::Handlers
end

module Psych::JSON
end

module Psych::JSON::RubyEvents
  def visit_DateTime(o); end

  def visit_String(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end
end

module Psych::JSON::RubyEvents
end

class Psych::JSON::Stream
  include ::Psych::Streaming
end

class Psych::JSON::Stream::Emitter
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::Stream::Emitter
end

class Psych::JSON::Stream
  extend ::Psych::Streaming::ClassMethods
end

class Psych::JSON::TreeBuilder
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::TreeBuilder
end

module Psych::JSON::YAMLEvents
  def end_document(implicit_end=T.unsafe(nil)); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end
end

module Psych::JSON::YAMLEvents
end

module Psych::JSON
end

module Psych::Nodes
end

class Psych::Nodes::Alias
  def anchor(); end

  def anchor=(anchor); end

  def initialize(anchor); end
end

class Psych::Nodes::Alias
end

class Psych::Nodes::Document
  def implicit(); end

  def implicit=(implicit); end

  def implicit_end(); end

  def implicit_end=(implicit_end); end

  def initialize(version=T.unsafe(nil), tag_directives=T.unsafe(nil), implicit=T.unsafe(nil)); end

  def root(); end

  def tag_directives(); end

  def tag_directives=(tag_directives); end

  def version(); end

  def version=(version); end
end

class Psych::Nodes::Document
end

class Psych::Nodes::Mapping
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Mapping
end

class Psych::Nodes::Node
  include ::Enumerable
  def children(); end

  def each(&block); end

  def end_column(); end

  def end_column=(end_column); end

  def end_line(); end

  def end_line=(end_line); end

  def start_column(); end

  def start_column=(start_column); end

  def start_line(); end

  def start_line=(start_line); end

  def tag(); end

  def to_ruby(); end

  def to_yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end

  def transform(); end

  def yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Psych::Nodes::Node
end

class Psych::Nodes::Scalar
  def anchor(); end

  def anchor=(anchor); end

  def initialize(value, anchor=T.unsafe(nil), tag=T.unsafe(nil), plain=T.unsafe(nil), quoted=T.unsafe(nil), style=T.unsafe(nil)); end

  def plain(); end

  def plain=(plain); end

  def quoted(); end

  def quoted=(quoted); end

  def style(); end

  def style=(style); end

  def tag=(tag); end

  def value(); end

  def value=(value); end
  ANY = ::T.let(nil, ::T.untyped)
  DOUBLE_QUOTED = ::T.let(nil, ::T.untyped)
  FOLDED = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
  PLAIN = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTED = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Scalar
end

class Psych::Nodes::Sequence
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Sequence
end

class Psych::Nodes::Stream
  def encoding(); end

  def encoding=(encoding); end

  def initialize(encoding=T.unsafe(nil)); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Stream
end

module Psych::Nodes
end

class Psych::Omap
end

class Psych::Omap
end

class Psych::Parser
  def external_encoding=(external_encoding); end

  def handler(); end

  def handler=(handler); end

  def initialize(handler=T.unsafe(nil)); end

  def mark(); end

  def parse(*_); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Parser::Mark
end

class Psych::Parser::Mark
end

class Psych::Parser
end

class Psych::ScalarScanner
  def class_loader(); end

  def initialize(class_loader); end

  def parse_int(string); end

  def parse_time(string); end

  def tokenize(string); end
  FLOAT = ::T.let(nil, ::T.untyped)
  INTEGER = ::T.let(nil, ::T.untyped)
  TIME = ::T.let(nil, ::T.untyped)
end

class Psych::ScalarScanner
end

class Psych::Set
end

class Psych::Set
end

class Psych::Stream
  include ::Psych::Streaming
end

class Psych::Stream::Emitter
  def end_document(implicit_end=T.unsafe(nil)); end
end

class Psych::Stream::Emitter
end

class Psych::Stream
  extend ::Psych::Streaming::ClassMethods
end

module Psych::Streaming
  def start(encoding=T.unsafe(nil)); end
end

module Psych::Streaming::ClassMethods
  def new(io); end
end

module Psych::Streaming::ClassMethods
end

module Psych::Streaming
end

class Psych::SyntaxError
  def column(); end

  def context(); end

  def file(); end

  def initialize(file, line, col, offset, problem, context); end

  def line(); end

  def offset(); end

  def problem(); end
end

class Psych::SyntaxError
end

class Psych::TreeBuilder
  def end_document(implicit_end=T.unsafe(nil)); end

  def root(); end
end

class Psych::TreeBuilder
end

module Psych::Visitors
end

class Psych::Visitors::DepthFirst
  def initialize(block); end
end

class Psych::Visitors::DepthFirst
end

class Psych::Visitors::Emitter
  def initialize(io, options=T.unsafe(nil)); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
end

class Psych::Visitors::Emitter
end

class Psych::Visitors::JSONTree
  include ::Psych::JSON::RubyEvents
end

class Psych::Visitors::JSONTree
  def self.create(options=T.unsafe(nil)); end
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::ToRuby
  def class_loader(); end

  def initialize(ss, class_loader); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
  SHOVEL = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::ToRuby
  def self.create(); end
end

class Psych::Visitors::Visitor
  def accept(target); end
  DISPATCH = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::Visitor
end

class Psych::Visitors::YAMLTree
  def <<(object); end

  def finish(); end

  def finished(); end

  def finished?(); end

  def initialize(emitter, ss, options); end

  def push(object); end

  def start(encoding=T.unsafe(nil)); end

  def started(); end

  def started?(); end

  def tree(); end

  def visit_Array(o); end

  def visit_BasicObject(o); end

  def visit_BigDecimal(o); end

  def visit_Class(o); end

  def visit_Complex(o); end

  def visit_Date(o); end

  def visit_DateTime(o); end

  def visit_Delegator(o); end

  def visit_Encoding(o); end

  def visit_Enumerator(o); end

  def visit_Exception(o); end

  def visit_FalseClass(o); end

  def visit_Float(o); end

  def visit_Hash(o); end

  def visit_Integer(o); end

  def visit_Module(o); end

  def visit_NameError(o); end

  def visit_NilClass(o); end

  def visit_Object(o); end

  def visit_Psych_Omap(o); end

  def visit_Psych_Set(o); end

  def visit_Range(o); end

  def visit_Rational(o); end

  def visit_Regexp(o); end

  def visit_String(o); end

  def visit_Struct(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end

  def visit_TrueClass(o); end
end

class Psych::Visitors::YAMLTree
  def self.create(options=T.unsafe(nil), emitter=T.unsafe(nil)); end
end

module Psych::Visitors
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump(o, io=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.dump_stream(*objects); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load(yaml, filename=T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.load_file(filename, fallback: T.unsafe(nil)); end

  def self.load_stream(yaml, filename=T.unsafe(nil)); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.parse(yaml, filename=T.unsafe(nil), fallback: T.unsafe(nil)); end

  def self.parse_file(filename); end

  def self.parse_stream(yaml, filename=T.unsafe(nil), &block); end

  def self.parser(); end

  def self.remove_type(type_tag); end

  def self.safe_load(yaml, whitelist_classes=T.unsafe(nil), whitelist_symbols=T.unsafe(nil), aliases=T.unsafe(nil), filename=T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.to_json(object); end
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

module Rack
  CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  ETAG = ::T.let(nil, ::T.untyped)
  GET = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTP_COOKIE = ::T.let(nil, ::T.untyped)
  HTTP_HOST = ::T.let(nil, ::T.untyped)
  HTTP_VERSION = ::T.let(nil, ::T.untyped)
  LINK = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  POST = ::T.let(nil, ::T.untyped)
  PUT = ::T.let(nil, ::T.untyped)
  QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_ERRORS = ::T.let(nil, ::T.untyped)
  RACK_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_HIJACK_IO = ::T.let(nil, ::T.untyped)
  RACK_INPUT = ::T.let(nil, ::T.untyped)
  RACK_IS_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_LOGGER = ::T.let(nil, ::T.untyped)
  RACK_METHODOVERRIDE_ORIGINAL_METHOD = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  RACK_MULTIPROCESS = ::T.let(nil, ::T.untyped)
  RACK_MULTITHREAD = ::T.let(nil, ::T.untyped)
  RACK_RECURSIVE_INCLUDE = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_STRING = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_INPUT = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_VARS = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_RUNONCE = ::T.let(nil, ::T.untyped)
  RACK_SESSION = ::T.let(nil, ::T.untyped)
  RACK_SESSION_OPTIONS = ::T.let(nil, ::T.untyped)
  RACK_SESSION_UNPACKED_COOKIE_DATA = ::T.let(nil, ::T.untyped)
  RACK_SHOWSTATUS_DETAIL = ::T.let(nil, ::T.untyped)
  RACK_TEMPFILES = ::T.let(nil, ::T.untyped)
  RACK_URL_SCHEME = ::T.let(nil, ::T.untyped)
  RACK_VERSION = ::T.let(nil, ::T.untyped)
  RELEASE = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_PATH = ::T.let(nil, ::T.untyped)
  SCRIPT_NAME = ::T.let(nil, ::T.untyped)
  SERVER_ADDR = ::T.let(nil, ::T.untyped)
  SERVER_NAME = ::T.let(nil, ::T.untyped)
  SERVER_PORT = ::T.let(nil, ::T.untyped)
  SERVER_PROTOCOL = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
  TRACE = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  UNLINK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::AbstractHandler
  def initialize(app, realm=T.unsafe(nil), &authenticator); end

  def realm(); end

  def realm=(realm); end
end

class Rack::Auth::AbstractHandler
end

class Rack::Auth::AbstractRequest
  def initialize(env); end

  def params(); end

  def parts(); end

  def provided?(); end

  def request(); end

  def scheme(); end

  def valid?(); end
  AUTHORIZATION_KEYS = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::AbstractRequest
end

class Rack::Auth::Basic
  def call(env); end
end

class Rack::Auth::Basic::Request
  def basic?(); end

  def credentials(); end

  def username(); end
end

class Rack::Auth::Basic::Request
end

class Rack::Auth::Basic
end

class Rack::Auth::Digest::MD5
  def call(env); end

  def initialize(app, realm=T.unsafe(nil), opaque=T.unsafe(nil), &authenticator); end

  def opaque(); end

  def opaque=(opaque); end

  def passwords_hashed=(passwords_hashed); end

  def passwords_hashed?(); end
  QOP = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::MD5
end

class Rack::Auth::Digest::Nonce
  def digest(); end

  def fresh?(); end

  def initialize(timestamp=T.unsafe(nil), given_digest=T.unsafe(nil)); end

  def stale?(); end

  def valid?(); end
end

class Rack::Auth::Digest::Nonce
  def self.parse(string); end

  def self.private_key(); end

  def self.private_key=(private_key); end

  def self.time_limit(); end

  def self.time_limit=(time_limit); end
end

class Rack::Auth::Digest::Params
  def [](k); end

  def []=(k, v); end

  def initialize(); end

  def quote(str); end
  UNQUOTED = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::Params
  def self.dequote(str); end

  def self.parse(str); end

  def self.split_header_value(str); end
end

class Rack::Auth::Digest::Request
  def correct_uri?(); end

  def digest?(); end

  def method(); end

  def method_missing(sym, *args); end

  def nonce(); end

  def respond_to?(sym, *_); end
end

class Rack::Auth::Digest::Request
end

class Rack::BodyProxy
  def close(); end

  def closed?(); end

  def each(&blk); end

  def initialize(body, &block); end

  def method_missing(method_name, *args, &block); end

  def respond_to?(method_name, include_all=T.unsafe(nil)); end
end

class Rack::BodyProxy
end

class Rack::Builder
  def call(env); end

  def initialize(default_app=T.unsafe(nil), &block); end

  def map(path, &block); end

  def run(app); end

  def to_app(); end

  def use(middleware, *args, &block); end

  def warmup(prc=T.unsafe(nil), &block); end
end

class Rack::Builder
  def self.app(default_app=T.unsafe(nil), &block); end

  def self.new_from_string(builder_script, file=T.unsafe(nil)); end

  def self.parse_file(config, opts=T.unsafe(nil)); end
end

class Rack::Cascade
  def <<(app); end

  def add(app); end

  def apps(); end

  def call(env); end

  def include?(app); end

  def initialize(apps, catch=T.unsafe(nil)); end
  NotFound = ::T.let(nil, ::T.untyped)
end

class Rack::Cascade
end

class Rack::Chunked
  include ::Rack::Utils
  def call(env); end

  def chunkable_version?(ver); end

  def initialize(app); end
end

class Rack::Chunked::Body
  include ::Rack::Utils
  def close(); end

  def each(&blk); end

  def initialize(body); end
  TAIL = ::T.let(nil, ::T.untyped)
  TERM = ::T.let(nil, ::T.untyped)
end

class Rack::Chunked::Body
end

class Rack::Chunked
end

class Rack::CommonLogger
  def call(env); end

  def initialize(app, logger=T.unsafe(nil)); end
  FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::CommonLogger
end

class Rack::ConditionalGet
  def call(env); end

  def initialize(app); end
end

class Rack::ConditionalGet
end

class Rack::Config
  def call(env); end

  def initialize(app, &block); end
end

class Rack::Config
end

class Rack::ContentLength
  include ::Rack::Utils
  def call(env); end

  def initialize(app); end
end

class Rack::ContentLength
end

class Rack::ContentType
  include ::Rack::Utils
  def call(env); end

  def initialize(app, content_type=T.unsafe(nil)); end
end

class Rack::ContentType
end

class Rack::Deflater
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
end

class Rack::Deflater::GzipStream
  def close(); end

  def each(&block); end

  def initialize(body, mtime); end

  def write(data); end
end

class Rack::Deflater::GzipStream
end

class Rack::Deflater
end

class Rack::Directory
  def call(env); end

  def check_bad_request(path_info); end

  def check_forbidden(path_info); end

  def entity_not_found(path_info); end

  def filesize_format(int); end

  def get(env); end

  def initialize(root, app=T.unsafe(nil)); end

  def list_directory(path_info, path, script_name); end

  def list_path(env, path, path_info, script_name); end

  def path(); end

  def root(); end

  def stat(node); end
  DIR_FILE = ::T.let(nil, ::T.untyped)
  DIR_PAGE = ::T.let(nil, ::T.untyped)
  FILESIZE_FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::Directory::DirectoryBody
end

class Rack::Directory::DirectoryBody
end

class Rack::Directory
end

class Rack::ETag
  def call(env); end

  def initialize(app, no_cache_control=T.unsafe(nil), cache_control=T.unsafe(nil)); end
  DEFAULT_CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  ETAG_STRING = ::T.let(nil, ::T.untyped)
end

class Rack::ETag
end

class Rack::File
  def call(env); end

  def get(env); end

  def initialize(root, headers=T.unsafe(nil), default_mime=T.unsafe(nil)); end

  def root(); end

  def serving(request, path); end
  ALLOWED_VERBS = ::T.let(nil, ::T.untyped)
  ALLOW_HEADER = ::T.let(nil, ::T.untyped)
end

class Rack::File::Iterator
  def close(); end

  def each(&blk); end

  def initialize(path, range); end

  def path(); end

  def range(); end

  def to_path(); end
end

class Rack::File::Iterator
end

class Rack::File
end

class Rack::ForwardRequest
  def env(); end

  def initialize(url, env=T.unsafe(nil)); end

  def url(); end
end

class Rack::ForwardRequest
end

module Rack::Handler
end

class Rack::Handler::CGI
end

class Rack::Handler::CGI
  def self.run(app, options=T.unsafe(nil)); end

  def self.send_body(body); end

  def self.send_headers(status, headers); end

  def self.serve(app); end
end

class Rack::Handler::WEBrick
  def initialize(server, app); end
end

class Rack::Handler::WEBrick
  def self.run(app, options=T.unsafe(nil)); end

  def self.shutdown(); end

  def self.valid_options(); end
end

module Rack::Handler
  def self.default(); end

  def self.get(server); end

  def self.pick(server_names); end

  def self.register(server, klass); end

  def self.try_require(prefix, const_name); end
end

class Rack::Head
  def call(env); end

  def initialize(app); end
end

class Rack::Head
end

class Rack::Lint
  include ::Rack::Lint::Assertion
  def _call(env); end

  def call(env=T.unsafe(nil)); end

  def check_content_length(status, headers); end

  def check_content_type(status, headers); end

  def check_env(env); end

  def check_error(error); end

  def check_headers(header); end

  def check_hijack(env); end

  def check_hijack_response(headers, env); end

  def check_input(input); end

  def check_status(status); end

  def close(); end

  def each(&blk); end

  def initialize(app); end

  def verify_content_length(bytes); end
end

module Rack::Lint::Assertion
  def assert(message); end
end

module Rack::Lint::Assertion
end

class Rack::Lint::ErrorWrapper
  include ::Rack::Lint::Assertion
  def close(*args); end

  def flush(); end

  def initialize(error); end

  def puts(str); end

  def write(str); end
end

class Rack::Lint::ErrorWrapper
end

class Rack::Lint::HijackWrapper
  include ::Rack::Lint::Assertion
  def close(*args, &block); end

  def close_read(*args, &block); end

  def close_write(*args, &block); end

  def closed?(*args, &block); end

  def flush(*args, &block); end

  def initialize(io); end

  def read(*args, &block); end

  def read_nonblock(*args, &block); end

  def write(*args, &block); end

  def write_nonblock(*args, &block); end
  REQUIRED_METHODS = ::T.let(nil, ::T.untyped)
end

class Rack::Lint::HijackWrapper
end

class Rack::Lint::InputWrapper
  include ::Rack::Lint::Assertion
  def close(*args); end

  def each(*args, &blk); end

  def gets(*args); end

  def initialize(input); end

  def read(*args); end

  def rewind(*args); end
end

class Rack::Lint::InputWrapper
end

class Rack::Lint::LintError
end

class Rack::Lint::LintError
end

class Rack::Lint
end

class Rack::Lock
  def call(env); end

  def initialize(app, mutex=T.unsafe(nil)); end
end

class Rack::Lock
end

class Rack::Logger
  def call(env); end

  def initialize(app, level=T.unsafe(nil)); end
end

class Rack::Logger
end

class Rack::MediaType
  SPLIT_PATTERN = ::T.let(nil, ::T.untyped)
end

class Rack::MediaType
  def self.params(content_type); end

  def self.type(content_type); end
end

class Rack::MethodOverride
  def call(env); end

  def initialize(app); end

  def method_override(env); end
  ALLOWED_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_OVERRIDE_HEADER = ::T.let(nil, ::T.untyped)
  METHOD_OVERRIDE_PARAM_KEY = ::T.let(nil, ::T.untyped)
end

class Rack::MethodOverride
end

module Rack::Mime
  MIME_TYPES = ::T.let(nil, ::T.untyped)
end

module Rack::Mime
  def self.match?(value, matcher); end

  def self.mime_type(ext, fallback=T.unsafe(nil)); end
end

class Rack::MockRequest
  def delete(uri, opts=T.unsafe(nil)); end

  def get(uri, opts=T.unsafe(nil)); end

  def head(uri, opts=T.unsafe(nil)); end

  def initialize(app); end

  def options(uri, opts=T.unsafe(nil)); end

  def patch(uri, opts=T.unsafe(nil)); end

  def post(uri, opts=T.unsafe(nil)); end

  def put(uri, opts=T.unsafe(nil)); end

  def request(method=T.unsafe(nil), uri=T.unsafe(nil), opts=T.unsafe(nil)); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

class Rack::MockRequest::FatalWarner
  def flush(); end

  def puts(warning); end

  def string(); end

  def write(warning); end
end

class Rack::MockRequest::FatalWarner
end

class Rack::MockRequest::FatalWarning
end

class Rack::MockRequest::FatalWarning
end

class Rack::MockRequest
  def self.env_for(uri=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.parse_uri_rfc2396(uri); end
end

class Rack::MockResponse
  def =~(other); end

  def errors(); end

  def errors=(errors); end

  def initialize(status, headers, body, errors=T.unsafe(nil)); end

  def match(other); end

  def original_headers(); end
end

class Rack::MockResponse
end

class Rack::MockSession
  def after_request(&block); end

  def clear_cookies(); end

  def cookie_jar(); end

  def cookie_jar=(cookie_jar); end

  def default_host(); end

  def initialize(app, default_host=T.unsafe(nil)); end

  def last_request(); end

  def last_response(); end

  def request(uri, env); end

  def set_cookie(cookie, uri=T.unsafe(nil)); end
end

class Rack::MockSession
end

module Rack::Multipart
  ATTRIBUTE = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_CHAR = ::T.let(nil, ::T.untyped)
  BROKEN_QUOTED = ::T.let(nil, ::T.untyped)
  BROKEN_UNQUOTED = ::T.let(nil, ::T.untyped)
  CONDISP = ::T.let(nil, ::T.untyped)
  DISPPARM = ::T.let(nil, ::T.untyped)
  EOL = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_PARAMETER = ::T.let(nil, ::T.untyped)
  MULTIPART = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_DISPOSITION = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_ID = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER_NAME = ::T.let(nil, ::T.untyped)
  RFC2183 = ::T.let(nil, ::T.untyped)
  SECTION = ::T.let(nil, ::T.untyped)
  TOKEN = ::T.let(nil, ::T.untyped)
  VALUE = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Generator
  def dump(); end

  def initialize(params, first=T.unsafe(nil)); end
end

class Rack::Multipart::Generator
end

class Rack::Multipart::MultipartPartLimitError
end

class Rack::Multipart::MultipartPartLimitError
end

class Rack::Multipart::Parser
  def initialize(boundary, tempfile, bufsize, query_parser); end

  def on_read(content); end

  def result(); end

  def state(); end
  BUFSIZE = ::T.let(nil, ::T.untyped)
  CHARSET = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  TEXT_PLAIN = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Parser::BoundedIO
  def initialize(io, content_length); end

  def read(size); end

  def rewind(); end
end

class Rack::Multipart::Parser::BoundedIO
end

class Rack::Multipart::Parser::Collector
  include ::Enumerable
  def each(&blk); end

  def initialize(tempfile); end

  def on_mime_body(mime_index, content); end

  def on_mime_finish(mime_index); end

  def on_mime_head(mime_index, head, filename, content_type, name); end
end

class Rack::Multipart::Parser::Collector::BufferPart
  def close(); end

  def file?(); end
end

class Rack::Multipart::Parser::Collector::BufferPart
end

class Rack::Multipart::Parser::Collector::MimePart
  def get_data(); end
end

class Rack::Multipart::Parser::Collector::MimePart
end

class Rack::Multipart::Parser::Collector::TempfilePart
  def close(); end

  def file?(); end
end

class Rack::Multipart::Parser::Collector::TempfilePart
end

class Rack::Multipart::Parser::Collector
end

class Rack::Multipart::Parser::MultipartInfo
  def params(); end

  def params=(_); end

  def tmp_files(); end

  def tmp_files=(_); end
end

class Rack::Multipart::Parser::MultipartInfo
  def self.[](*_); end

  def self.members(); end
end

class Rack::Multipart::Parser
  def self.parse(io, content_length, content_type, tmpfile, bufsize, qp); end

  def self.parse_boundary(content_type); end
end

class Rack::Multipart::UploadedFile
  def content_type(); end

  def content_type=(content_type); end

  def initialize(path, content_type=T.unsafe(nil), binary=T.unsafe(nil)); end

  def local_path(); end

  def method_missing(method_name, *args, &block); end

  def original_filename(); end

  def path(); end

  def respond_to?(*args); end
end

class Rack::Multipart::UploadedFile
end

module Rack::Multipart
  def self.build_multipart(params, first=T.unsafe(nil)); end

  def self.extract_multipart(req, params=T.unsafe(nil)); end

  def self.parse_multipart(env, params=T.unsafe(nil)); end
end

class Rack::NullLogger
  def <<(msg); end

  def add(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def call(env); end

  def close(); end

  def datetime_format(); end

  def datetime_format=(datetime_format); end

  def debug(progname=T.unsafe(nil), &block); end

  def debug?(); end

  def error(progname=T.unsafe(nil), &block); end

  def error?(); end

  def fatal(progname=T.unsafe(nil), &block); end

  def fatal?(); end

  def formatter(); end

  def formatter=(formatter); end

  def info(progname=T.unsafe(nil), &block); end

  def info?(); end

  def initialize(app); end

  def level(); end

  def level=(level); end

  def progname(); end

  def progname=(progname); end

  def sev_threshold(); end

  def sev_threshold=(sev_threshold); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end

  def warn?(); end
end

class Rack::NullLogger
end

class Rack::QueryParser
  def initialize(params_class, key_space_limit, param_depth_limit); end

  def key_space_limit(); end

  def make_params(); end

  def new_depth_limit(param_depth_limit); end

  def new_space_limit(key_space_limit); end

  def normalize_params(params, name, v, depth); end

  def param_depth_limit(); end

  def parse_nested_query(qs, d=T.unsafe(nil)); end

  def parse_query(qs, d=T.unsafe(nil), &unescaper); end
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
end

class Rack::QueryParser::InvalidParameterError
end

class Rack::QueryParser::InvalidParameterError
end

class Rack::QueryParser::ParameterTypeError
end

class Rack::QueryParser::ParameterTypeError
end

class Rack::QueryParser::Params
  def [](key); end

  def []=(key, value); end

  def initialize(limit); end

  def key?(key); end

  def to_params_hash(); end
end

class Rack::QueryParser::Params
end

class Rack::QueryParser
  def self.make_default(key_space_limit, param_depth_limit); end
end

class Rack::Recursive
  def _call(env); end

  def call(env); end

  def include(env, path); end

  def initialize(app); end
end

class Rack::Recursive
end

class Rack::Reloader
  def call(env); end

  def initialize(app, cooldown=T.unsafe(nil), backend=T.unsafe(nil)); end

  def reload!(stderr=T.unsafe(nil)); end

  def safe_load(file, mtime, stderr=T.unsafe(nil)); end
end

module Rack::Reloader::Stat
  def figure_path(file, paths); end

  def rotation(); end

  def safe_stat(file); end
end

module Rack::Reloader::Stat
end

class Rack::Reloader
end

class Rack::Request
  include ::Rack::Request::Env
  include ::Rack::Request::Helpers
  SCHEME_WHITELIST = ::T.let(nil, ::T.untyped)
end

module Rack::Request::Env
  def add_header(key, v); end

  def delete_header(name); end

  def each_header(&block); end

  def env(); end

  def fetch_header(name, &block); end

  def get_header(name); end

  def has_header?(name); end

  def initialize(env); end

  def set_header(name, v); end
end

module Rack::Request::Env
end

module Rack::Request::Helpers
  def GET(); end

  def POST(); end

  def [](key); end

  def []=(key, value); end

  def accept_encoding(); end

  def accept_language(); end

  def authority(); end

  def base_url(); end

  def body(); end

  def content_charset(); end

  def content_length(); end

  def content_type(); end

  def cookies(); end

  def delete?(); end

  def delete_param(k); end

  def form_data?(); end

  def fullpath(); end

  def get?(); end

  def head?(); end

  def host(); end

  def host_with_port(); end

  def ip(); end

  def link?(); end

  def logger(); end

  def media_type(); end

  def media_type_params(); end

  def multithread?(); end

  def options?(); end

  def params(); end

  def parseable_data?(); end

  def patch?(); end

  def path(); end

  def path_info(); end

  def path_info=(s); end

  def port(); end

  def post?(); end

  def put?(); end

  def query_string(); end

  def referer(); end

  def referrer(); end

  def request_method(); end

  def scheme(); end

  def script_name(); end

  def script_name=(s); end

  def session(); end

  def session_options(); end

  def ssl?(); end

  def trace?(); end

  def trusted_proxy?(ip); end

  def unlink?(); end

  def update_param(k, v); end

  def url(); end

  def user_agent(); end

  def values_at(*keys); end

  def xhr?(); end
  DEFAULT_PORTS = ::T.let(nil, ::T.untyped)
  FORM_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_HOST = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PORT = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PROTO = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SCHEME = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SSL = ::T.let(nil, ::T.untyped)
  PARSEABLE_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
end

module Rack::Request::Helpers
end

class Rack::Request
end

class Rack::Response
  include ::Rack::Response::Helpers
  def [](key); end

  def []=(key, v); end

  def body(); end

  def body=(body); end

  def chunked?(); end

  def close(); end

  def delete_header(key); end

  def each(&callback); end

  def empty?(); end

  def finish(&block); end

  def get_header(key); end

  def has_header?(key); end

  def header(); end

  def headers(); end

  def initialize(body=T.unsafe(nil), status=T.unsafe(nil), header=T.unsafe(nil)); end

  def length(); end

  def length=(length); end

  def redirect(target, status=T.unsafe(nil)); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end

  def to_a(&block); end

  def to_ary(&block); end

  def write(str); end
  CHUNKED = ::T.let(nil, ::T.untyped)
end

module Rack::Response::Helpers
  def accepted?(); end

  def add_header(key, v); end

  def bad_request?(); end

  def cache_control(); end

  def cache_control=(v); end

  def client_error?(); end

  def content_length(); end

  def content_type(); end

  def created?(); end

  def delete_cookie(key, value=T.unsafe(nil)); end

  def etag(); end

  def etag=(v); end

  def forbidden?(); end

  def include?(header); end

  def informational?(); end

  def invalid?(); end

  def location(); end

  def location=(location); end

  def media_type(); end

  def media_type_params(); end

  def method_not_allowed?(); end

  def moved_permanently?(); end

  def no_content?(); end

  def not_found?(); end

  def ok?(); end

  def precondition_failed?(); end

  def redirect?(); end

  def redirection?(); end

  def server_error?(); end

  def set_cookie(key, value); end

  def set_cookie_header(); end

  def set_cookie_header=(v); end

  def successful?(); end

  def unauthorized?(); end

  def unprocessable?(); end
end

module Rack::Response::Helpers
end

class Rack::Response::Raw
  include ::Rack::Response::Helpers
  def delete_header(key); end

  def get_header(key); end

  def has_header?(key); end

  def headers(); end

  def initialize(status, headers); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end
end

class Rack::Response::Raw
end

class Rack::Response
end

class Rack::Runtime
  def call(env); end

  def initialize(app, name=T.unsafe(nil)); end
  FORMAT_STRING = ::T.let(nil, ::T.untyped)
  HEADER_NAME = ::T.let(nil, ::T.untyped)
end

class Rack::Runtime
end

class Rack::Sendfile
  def call(env); end

  def initialize(app, variation=T.unsafe(nil), mappings=T.unsafe(nil)); end
end

class Rack::Sendfile
end

class Rack::Server
  def app(); end

  def default_options(); end

  def initialize(options=T.unsafe(nil)); end

  def middleware(); end

  def options(); end

  def options=(options); end

  def server(); end

  def start(&blk); end
end

class Rack::Server::Options
  def handler_opts(options); end

  def parse!(args); end
end

class Rack::Server::Options
end

class Rack::Server
  def self.default_middleware_by_environment(); end

  def self.logging_middleware(); end

  def self.middleware(); end

  def self.start(options=T.unsafe(nil)); end
end

module Rack::Session::Abstract
end

class Rack::Session::Abstract::ID
  def find_session(req, sid); end
end

class Rack::Session::Abstract::ID
  def self.inherited(klass); end
end

class Rack::Session::Abstract::Persisted
  def call(env); end

  def commit_session(req, res); end

  def context(env, app=T.unsafe(nil)); end

  def default_options(); end

  def initialize(app, options=T.unsafe(nil)); end

  def key(); end

  def sid_secure(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::Persisted
end

class Rack::Session::Abstract::PersistedSecure
  def extract_session_id(*_); end

  def generate_sid(*_); end
end

class Rack::Session::Abstract::PersistedSecure
end

class Rack::Session::Abstract::SessionHash
  include ::Enumerable
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def delete(key); end

  def destroy(); end

  def each(&block); end

  def empty?(); end

  def exists?(); end

  def fetch(key, default=T.unsafe(nil), &block); end

  def has_key?(key); end

  def id(); end

  def id=(id); end

  def include?(key); end

  def initialize(store, req); end

  def key?(key); end

  def keys(); end

  def loaded?(); end

  def merge!(hash); end

  def options(); end

  def replace(hash); end

  def store(key, value); end

  def to_hash(); end

  def update(hash); end

  def values(); end
  Unspecified = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::SessionHash
  def self.find(req); end

  def self.set(req, session); end

  def self.set_options(req, options); end
end

module Rack::Session::Abstract
end

class Rack::Session::Cookie
  def coder(); end
end

class Rack::Session::Cookie::Base64
  def decode(str); end

  def encode(str); end
end

class Rack::Session::Cookie::Base64::JSON
  def encode(obj); end
end

class Rack::Session::Cookie::Base64::JSON
end

class Rack::Session::Cookie::Base64::Marshal
end

class Rack::Session::Cookie::Base64::Marshal
end

class Rack::Session::Cookie::Base64::ZipJSON
  def encode(obj); end
end

class Rack::Session::Cookie::Base64::ZipJSON
end

class Rack::Session::Cookie::Base64
end

class Rack::Session::Cookie::Identity
  def decode(str); end

  def encode(str); end
end

class Rack::Session::Cookie::Identity
end

class Rack::Session::Cookie::SessionId
  def cookie_value(); end

  def initialize(session_id, cookie_value); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Cookie::SessionId
end

class Rack::Session::Cookie
end

class Rack::Session::Pool
  def delete_session(req, session_id, options); end

  def find_session(req, sid); end

  def generate_sid(); end

  def mutex(); end

  def pool(); end

  def with_lock(req); end

  def write_session(req, session_id, new_session, options); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Pool
end

class Rack::Session::SessionId
  def cookie_value(); end

  def empty?(); end

  def initialize(public_id); end

  def private_id(); end

  def public_id(); end
  ID_VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Session::SessionId
end

class Rack::ShowExceptions
  def call(env); end

  def dump_exception(exception); end

  def h(obj); end

  def initialize(app); end

  def prefers_plaintext?(env); end

  def pretty(env, exception); end
  CONTEXT = ::T.let(nil, ::T.untyped)
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowExceptions
end

class Rack::ShowStatus
  def call(env); end

  def h(obj); end

  def initialize(app); end
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowStatus
end

class Rack::Static
  def add_index_root?(path); end

  def applicable_rules(path); end

  def call(env); end

  def can_serve(path); end

  def initialize(app, options=T.unsafe(nil)); end

  def overwrite_file_path(path); end

  def route_file(path); end
end

class Rack::Static
end

class Rack::TempfileReaper
  def call(env); end

  def initialize(app); end
end

class Rack::TempfileReaper
end

module Rack::Test
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Test::Cookie
  include ::Rack::Utils
  def default_uri(); end

  def domain(); end

  def empty?(); end

  def expired?(); end

  def expires(); end

  def http_only?(); end

  def initialize(raw, uri=T.unsafe(nil), default_host=T.unsafe(nil)); end

  def matches?(uri); end

  def name(); end

  def path(); end

  def raw(); end

  def replaces?(other); end

  def secure?(); end

  def to_h(); end

  def to_hash(); end

  def valid?(uri); end

  def value(); end
end

class Rack::Test::Cookie
end

class Rack::Test::CookieJar
  def <<(new_cookie); end

  def [](name); end

  def []=(name, value); end

  def delete(name); end

  def for(uri); end

  def get_cookie(name); end

  def hash_for(uri=T.unsafe(nil)); end

  def initialize(cookies=T.unsafe(nil), default_host=T.unsafe(nil)); end

  def merge(raw_cookies, uri=T.unsafe(nil)); end

  def to_hash(); end
  DELIMITER = ::T.let(nil, ::T.untyped)
end

class Rack::Test::CookieJar
end

class Rack::Test::Error
end

class Rack::Test::Error
end

module Rack::Test::Methods
  def _current_session_names(); end

  def authorize(*args, &block); end

  def basic_authorize(*args, &block); end

  def build_rack_mock_session(); end

  def build_rack_test_session(name); end

  def clear_cookies(*args, &block); end

  def current_session(); end

  def custom_request(*args, &block); end

  def delete(*args, &block); end

  def digest_authorize(*args, &block); end

  def env(*args, &block); end

  def follow_redirect!(*args, &block); end

  def get(*args, &block); end

  def head(*args, &block); end

  def header(*args, &block); end

  def last_request(*args, &block); end

  def last_response(*args, &block); end

  def options(*args, &block); end

  def patch(*args, &block); end

  def post(*args, &block); end

  def put(*args, &block); end

  def rack_mock_session(name=T.unsafe(nil)); end

  def rack_test_session(name=T.unsafe(nil)); end

  def request(*args, &block); end

  def set_cookie(*args, &block); end

  def with_session(name); end
  METHODS = ::T.let(nil, ::T.untyped)
end

module Rack::Test::Methods
end

class Rack::Test::MockDigestRequest
  def initialize(params); end

  def method(); end

  def method_missing(sym); end

  def response(password); end
end

class Rack::Test::MockDigestRequest
end

class Rack::Test::Session
  include ::Rack::Test::Utils
  include ::Rack::Utils
  def authorize(username, password); end

  def basic_authorize(username, password); end

  def clear_cookies(*args, &block); end

  def custom_request(verb, uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def delete(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def digest_authorize(username, password); end

  def env(name, value); end

  def follow_redirect!(); end

  def get(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def head(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def header(name, value); end

  def initialize(mock_session); end

  def last_request(*args, &block); end

  def last_response(*args, &block); end

  def options(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def patch(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def post(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def put(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def request(uri, env=T.unsafe(nil), &block); end

  def set_cookie(*args, &block); end
end

class Rack::Test::Session
end

class Rack::Test::UploadedFile
  def content_type(); end

  def content_type=(content_type); end

  def initialize(content, content_type=T.unsafe(nil), binary=T.unsafe(nil), original_filename: T.unsafe(nil)); end

  def local_path(); end

  def method_missing(method_name, *args, &block); end

  def original_filename(); end

  def path(); end

  def tempfile(); end
end

class Rack::Test::UploadedFile
  def self.actually_finalize(file); end

  def self.finalize(file); end
end

module Rack::Test::Utils
  include ::Rack::Utils
end

module Rack::Test::Utils
  extend ::Rack::Utils
  def self.build_file_part(parameter_name, uploaded_file); end

  def self.build_multipart(params, first=T.unsafe(nil), multipart=T.unsafe(nil)); end

  def self.build_parts(parameters); end

  def self.build_primitive_part(parameter_name, value); end

  def self.get_parts(parameters); end
end

module Rack::Test
  def self.encoding_aware_strings?(); end
end

class Rack::URLMap
  def call(env); end

  def initialize(map=T.unsafe(nil)); end

  def remap(map); end
  INFINITY = ::T.let(nil, ::T.untyped)
  NEGATIVE_INFINITY = ::T.let(nil, ::T.untyped)
end

class Rack::URLMap
end

module Rack::Utils
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML_PATTERN = ::T.let(nil, ::T.untyped)
  HTTP_STATUS_CODES = ::T.let(nil, ::T.untyped)
  NULL_BYTE = ::T.let(nil, ::T.untyped)
  PATH_SEPS = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
  SYMBOL_TO_STATUS_CODE = ::T.let(nil, ::T.untyped)
end

class Rack::Utils::Context
  def app(); end

  def call(env); end

  def context(env, app=T.unsafe(nil)); end

  def for(); end

  def initialize(app_f, app_r); end

  def recontext(app); end
end

class Rack::Utils::Context
end

class Rack::Utils::HeaderHash
  def [](k); end

  def []=(k, v); end

  def delete(k); end

  def has_key?(k); end

  def include?(k); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(k); end

  def member?(k); end

  def merge(other); end

  def merge!(other); end

  def names(); end

  def replace(other); end
end

class Rack::Utils::HeaderHash
  def self.new(hash=T.unsafe(nil)); end
end

Rack::Utils::InvalidParameterError = Rack::QueryParser::InvalidParameterError

Rack::Utils::KeySpaceConstrainedParams = Rack::QueryParser::Params

Rack::Utils::ParameterTypeError = Rack::QueryParser::ParameterTypeError

module Rack::Utils
  def self.add_cookie_to_header(header, key, value); end

  def self.add_remove_cookie_to_header(header, key, value=T.unsafe(nil)); end

  def self.best_q_match(q_value_header, available_mimes); end

  def self.build_nested_query(value, prefix=T.unsafe(nil)); end

  def self.build_query(params); end

  def self.byte_ranges(env, size); end

  def self.clean_path_info(path_info); end

  def self.clock_time(); end

  def self.default_query_parser(); end

  def self.default_query_parser=(default_query_parser); end

  def self.delete_cookie_header!(header, key, value=T.unsafe(nil)); end

  def self.escape(s); end

  def self.escape_html(string); end

  def self.escape_path(s); end

  def self.get_byte_ranges(http_range, size); end

  def self.key_space_limit(); end

  def self.key_space_limit=(v); end

  def self.make_delete_cookie_header(header, key, value); end

  def self.multipart_part_limit(); end

  def self.multipart_part_limit=(multipart_part_limit); end

  def self.param_depth_limit(); end

  def self.param_depth_limit=(v); end

  def self.parse_cookies(env); end

  def self.parse_cookies_header(header); end

  def self.parse_nested_query(qs, d=T.unsafe(nil)); end

  def self.parse_query(qs, d=T.unsafe(nil), &unescaper); end

  def self.q_values(q_value_header); end

  def self.rfc2109(time); end

  def self.rfc2822(time); end

  def self.secure_compare(a, b); end

  def self.select_best_encoding(available_encodings, accept_encoding); end

  def self.set_cookie_header!(header, key, value); end

  def self.status_code(status); end

  def self.unescape(s, encoding=T.unsafe(nil)); end

  def self.unescape_path(s); end

  def self.valid_path?(path); end
end

class Rails::Application
  INITIAL_VARIABLES = ::T.let(nil, ::T.untyped)
end

module Rails::Application::Bootstrap
  include ::Rails::Initializable
end

module Rails::Application::Bootstrap
end

class Rails::Application::Configuration
  def allow_concurrency(); end

  def allow_concurrency=(allow_concurrency); end

  def annotations(); end

  def api_only(); end

  def api_only=(value); end

  def asset_host(); end

  def asset_host=(asset_host); end

  def autoflush_log(); end

  def autoflush_log=(autoflush_log); end

  def beginning_of_week(); end

  def beginning_of_week=(beginning_of_week); end

  def cache_classes(); end

  def cache_classes=(cache_classes); end

  def cache_store(); end

  def cache_store=(cache_store); end

  def colorize_logging(); end

  def colorize_logging=(val); end

  def consider_all_requests_local(); end

  def consider_all_requests_local=(consider_all_requests_local); end

  def console(); end

  def console=(console); end

  def content_security_policy(&block); end

  def content_security_policy_nonce_generator(); end

  def content_security_policy_nonce_generator=(content_security_policy_nonce_generator); end

  def content_security_policy_report_only(); end

  def content_security_policy_report_only=(content_security_policy_report_only); end

  def database_configuration(); end

  def debug_exception_response_format(); end

  def debug_exception_response_format=(value); end

  def eager_load(); end

  def eager_load=(eager_load); end

  def enable_dependency_loading(); end

  def enable_dependency_loading=(enable_dependency_loading); end

  def encoding(); end

  def encoding=(value); end

  def exceptions_app(); end

  def exceptions_app=(exceptions_app); end

  def file_watcher(); end

  def file_watcher=(file_watcher); end

  def filter_parameters(); end

  def filter_parameters=(filter_parameters); end

  def filter_redirect(); end

  def filter_redirect=(filter_redirect); end

  def force_ssl(); end

  def force_ssl=(force_ssl); end

  def helpers_paths(); end

  def helpers_paths=(helpers_paths); end

  def initialize(*_); end

  def load_defaults(target_version); end

  def loaded_config_version(); end

  def log_formatter(); end

  def log_formatter=(log_formatter); end

  def log_level(); end

  def log_level=(log_level); end

  def log_tags(); end

  def log_tags=(log_tags); end

  def logger(); end

  def logger=(logger); end

  def public_file_server(); end

  def public_file_server=(public_file_server); end

  def railties_order(); end

  def railties_order=(railties_order); end

  def read_encrypted_secrets(); end

  def read_encrypted_secrets=(read_encrypted_secrets); end

  def relative_url_root(); end

  def relative_url_root=(relative_url_root); end

  def reload_classes_only_on_change(); end

  def reload_classes_only_on_change=(reload_classes_only_on_change); end

  def require_master_key(); end

  def require_master_key=(require_master_key); end

  def secret_key_base(); end

  def secret_key_base=(secret_key_base); end

  def secret_token(); end

  def secret_token=(secret_token); end

  def session_options(); end

  def session_options=(session_options); end

  def session_store(new_session_store=T.unsafe(nil), **options); end

  def session_store?(); end

  def ssl_options(); end

  def ssl_options=(ssl_options); end

  def time_zone(); end

  def time_zone=(time_zone); end

  def x(); end

  def x=(x); end
end

class Rails::Application::Configuration::Custom
  def method_missing(method, *args); end
end

class Rails::Application::Configuration::Custom
end

class Rails::Application::Configuration
end

class Rails::Application::DefaultMiddlewareStack
  def app(); end

  def build_stack(); end

  def config(); end

  def initialize(app, config, paths); end

  def paths(); end
end

class Rails::Application::DefaultMiddlewareStack
end

module Rails::Application::Finisher
  include ::Rails::Initializable
end

module Rails::Application::Finisher::InterlockHook
end

module Rails::Application::Finisher::InterlockHook
  def self.complete(_state); end

  def self.run(); end
end

class Rails::Application::Finisher::MutexHook
  def complete(_state); end

  def initialize(mutex=T.unsafe(nil)); end

  def run(); end
end

class Rails::Application::Finisher::MutexHook
end

module Rails::Application::Finisher
end

class Rails::Application::RoutesReloader
  def eager_load(); end

  def eager_load=(eager_load); end

  def execute(*args, &block); end

  def execute_if_updated(*args, &block); end

  def paths(); end

  def reload!(); end

  def route_sets(); end

  def updated?(*args, &block); end
end

class Rails::Application::RoutesReloader
end

module Rails::Dom
end

module Rails::Dom::Testing
end

module Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
end

module Rails::Dom::Testing::Assertions::DomAssertions
  def assert_dom_equal(expected, actual, message=T.unsafe(nil)); end

  def assert_dom_not_equal(expected, actual, message=T.unsafe(nil)); end

  def compare_doms(expected, actual); end

  def equal_attribute?(attr, other_attr); end

  def equal_attribute_nodes?(nodes, other_nodes); end

  def equal_children?(child, other_child); end
end

module Rails::Dom::Testing::Assertions::DomAssertions
end

module Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  def assert_select(*args, &block); end

  def assert_select_email(&block); end

  def assert_select_encoded(element=T.unsafe(nil), &block); end

  def css_select(*args); end
end

module Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
end

module Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  extend ::ActiveSupport::Concern
end

module Rails::Dom::Testing::Assertions::SelectorAssertions
end

module Rails::Dom::Testing::Assertions
  extend ::ActiveSupport::Concern
end

module Rails::Dom::Testing
end

module Rails::Dom
end

class Rails::Engine::Configuration
  def autoload_once_paths(); end

  def autoload_once_paths=(autoload_once_paths); end

  def autoload_paths(); end

  def autoload_paths=(autoload_paths); end

  def eager_load_paths(); end

  def eager_load_paths=(eager_load_paths); end

  def generators(); end

  def initialize(root=T.unsafe(nil)); end

  def middleware(); end

  def middleware=(middleware); end

  def paths(); end

  def root(); end

  def root=(value); end
end

class Rails::Engine::Configuration
end

module Rails::Html
  XPATHS_TO_REMOVE = ::T.let(nil, ::T.untyped)
end

class Rails::Html::FullSanitizer
end

class Rails::Html::FullSanitizer
end

class Rails::Html::LinkSanitizer
end

class Rails::Html::LinkSanitizer
end

class Rails::Html::PermitScrubber
  def allowed_node?(node); end

  def attributes(); end

  def attributes=(attributes); end

  def initialize(); end

  def keep_node?(node); end

  def scrub_attribute(node, attr_node); end

  def scrub_attribute?(name); end

  def scrub_attributes(node); end

  def scrub_css_attribute(node); end

  def scrub_node(node); end

  def skip_node?(node); end

  def tags(); end

  def tags=(tags); end

  def validate!(var, name); end
end

class Rails::Html::PermitScrubber
end

class Rails::Html::SafeListSanitizer
  def sanitize_css(style_string); end
end

class Rails::Html::SafeListSanitizer
  def self.allowed_attributes(); end

  def self.allowed_attributes=(allowed_attributes); end

  def self.allowed_tags(); end

  def self.allowed_tags=(allowed_tags); end
end

class Rails::Html::Sanitizer
  def sanitize(html, options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rails::Html::Sanitizer
  def self.full_sanitizer(); end

  def self.link_sanitizer(); end

  def self.safe_list_sanitizer(); end

  def self.white_list_sanitizer(); end
end

class Rails::Html::TargetScrubber
end

class Rails::Html::TargetScrubber
end

class Rails::Html::TextOnlyScrubber
  def initialize(); end
end

class Rails::Html::TextOnlyScrubber
end

Rails::Html::WhiteListSanitizer = Rails::Html::SafeListSanitizer

module Rails::Html
end

module Rails::Info
  def properties(); end

  def properties=(obj); end
end

module Rails::Info
  def self.properties(); end

  def self.properties=(obj); end

  def self.property(name, value=T.unsafe(nil)); end

  def self.to_html(); end
end

class Rails::Rack::Logger
  def call(env); end

  def initialize(app, taggers=T.unsafe(nil)); end
end

class Rails::Rack::Logger
end

class Rails::Railtie
  ABSTRACT_RAILTIES = ::T.let(nil, ::T.untyped)
end

module Rails::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module Rainbow
end

class Rainbow::Color
  def ground(); end
end

class Rainbow::Color::Indexed
  def codes(); end

  def initialize(ground, num); end

  def num(); end
end

class Rainbow::Color::Indexed
end

class Rainbow::Color::Named
  def initialize(ground, name); end
  NAMES = ::T.let(nil, ::T.untyped)
end

class Rainbow::Color::Named
  def self.color_names(); end

  def self.valid_names(); end
end

class Rainbow::Color::RGB
  def b(); end

  def g(); end

  def initialize(ground, *values); end

  def r(); end
end

class Rainbow::Color::RGB
  def self.to_ansi_domain(value); end
end

class Rainbow::Color::X11Named
  include ::Rainbow::X11ColorNames
  def initialize(ground, name); end
end

class Rainbow::Color::X11Named
  def self.color_names(); end

  def self.valid_names(); end
end

class Rainbow::Color
  def self.build(ground, values); end

  def self.parse_hex_color(hex); end
end

class Rainbow::NullPresenter
  def background(*_values); end

  def bg(*_values); end

  def black(); end

  def blink(); end

  def blue(); end

  def bold(); end

  def bright(); end

  def color(*_values); end

  def cyan(); end

  def dark(); end

  def faint(); end

  def fg(*_values); end

  def foreground(*_values); end

  def green(); end

  def hide(); end

  def inverse(); end

  def italic(); end

  def magenta(); end

  def method_missing(method_name, *args); end

  def red(); end

  def reset(); end

  def underline(); end

  def white(); end

  def yellow(); end
end

class Rainbow::NullPresenter
end

class Rainbow::Presenter
  def background(*values); end

  def bg(*values); end

  def black(); end

  def blink(); end

  def blue(); end

  def bold(); end

  def bright(); end

  def color(*values); end

  def cyan(); end

  def dark(); end

  def faint(); end

  def fg(*values); end

  def foreground(*values); end

  def green(); end

  def hide(); end

  def inverse(); end

  def italic(); end

  def magenta(); end

  def method_missing(method_name, *args); end

  def red(); end

  def reset(); end

  def underline(); end

  def white(); end

  def yellow(); end
  TERM_EFFECTS = ::T.let(nil, ::T.untyped)
end

class Rainbow::Presenter
end

class Rainbow::StringUtils
end

class Rainbow::StringUtils
  def self.uncolor(string); end

  def self.wrap_with_sgr(string, codes); end
end

class Rainbow::Wrapper
  def enabled(); end

  def enabled=(enabled); end

  def initialize(enabled=T.unsafe(nil)); end

  def wrap(string); end
end

class Rainbow::Wrapper
end

module Rainbow::X11ColorNames
  NAMES = ::T.let(nil, ::T.untyped)
end

module Rainbow::X11ColorNames
end

module Rainbow
  def self.enabled(); end

  def self.enabled=(value); end

  def self.global(); end

  def self.new(); end

  def self.uncolor(string); end
end

module Random::Formatter
  def alphanumeric(n=T.unsafe(nil)); end

  ALPHANUMERIC = ::T.let(nil, ::T.untyped)
end

class Random
  def self.urandom(_); end
end

class Range
  def sum(identity=T.unsafe(nil)); end
end

class Rational
  def to_d(precision); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.ruby(); end
end

class Regexp
  def match?(*_); end
end

class RubyVM::InstructionSequence
  def absolute_path(); end

  def base_label(); end

  def disasm(); end

  def disassemble(); end

  def each_child(); end

  def eval(); end

  def first_lineno(); end

  def label(); end

  def path(); end

  def to_a(); end

  def to_binary(*_); end

  def trace_points(); end
end

class RubyVM::InstructionSequence
  def self.compile(*_); end

  def self.compile_file(*_); end

  def self.compile_option(); end

  def self.compile_option=(compile_option); end

  def self.disasm(_); end

  def self.disassemble(_); end

  def self.load_from_binary(_); end

  def self.load_from_binary_extra_data(_); end

  def self.of(_); end
end

class RubyVM
  def self.stat(*_); end
end

ScanError = StringScanner::Error

module SecureRandom
  extend ::Random::Formatter
  def self.bytes(n); end
end

class Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

class SignalException
  def signm(); end

  def signo(); end
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

class Sorbet::Private::ConstantLookupCache
  def all_module_aliases(); end

  def all_module_names(); end

  def all_named_modules(); end

  def class_by_name(name); end

  def name_by_class(klass); end
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def aliases(); end

  def aliases=(_); end

  def const(); end

  def const=(_); end

  def const_name(); end

  def const_name=(_); end

  def found_name(); end

  def found_name=(_); end

  def owner(); end

  def owner=(_); end

  def primary_name(); end

  def primary_name=(_); end
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::ConstantLookupCache
end

class Sorbet::Private::CreateConfig
  include ::Sorbet::Private::StepInterface
  SORBET_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  SORBET_DIR = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::CreateConfig
  def self.main(); end

  def self.output_file(); end
end

class Sorbet::Private::FetchRBIs
  include ::Sorbet::Private::StepInterface
  HEADER = ::T.let(nil, ::T.untyped)
  RBI_CACHE_DIR = ::T.let(nil, ::T.untyped)
  SORBET_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  SORBET_DIR = ::T.let(nil, ::T.untyped)
  SORBET_RBI_LIST = ::T.let(nil, ::T.untyped)
  SORBET_RBI_SORBET_TYPED = ::T.let(nil, ::T.untyped)
  SORBET_TYPED_REPO = ::T.let(nil, ::T.untyped)
  SORBET_TYPED_REVISION = ::T.let(nil, ::T.untyped)
  XDG_CACHE_HOME = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::FetchRBIs
  def self.fetch_sorbet_typed(); end

  def self.main(); end

  def self.matching_version_directories(root, version); end

  def self.output_file(); end

  def self.paths_for_gem_version(gemspec); end

  def self.paths_for_ruby_version(ruby_version); end

  def self.vendor_rbis_within_paths(vendor_paths); end
end

class Sorbet::Private::FindGemRBIs
  include ::Sorbet::Private::StepInterface
  GEM_DIR = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  RBI_CACHE_DIR = ::T.let(nil, ::T.untyped)
  XDG_CACHE_HOME = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::FindGemRBIs
  def self.main(); end

  def self.output_file(); end

  def self.paths_within_gem_sources(gemspec); end
end

module Sorbet::Private::GemGeneratorTracepoint
  include ::Sorbet::Private::StepInterface
  OUTPUT = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def defs(); end

  def defs=(_); end

  def id(); end

  def id=(_); end

  def klass(); end

  def klass=(_); end
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::GemGeneratorTracepoint::TracepointSerializer
  def initialize(files:, delegate_classes:); end

  def serialize(output_dir); end
  BAD_METHODS = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemGeneratorTracepoint::TracepointSerializer
end

class Sorbet::Private::GemGeneratorTracepoint::Tracer
end

class Sorbet::Private::GemGeneratorTracepoint::Tracer
  def self.add_to_context(item); end

  def self.disable_tracepoints(); end

  def self.finish(); end

  def self.install_tracepoints(); end

  def self.on_method_added(mod, method, singleton); end

  def self.on_module_created(mod); end

  def self.on_module_extended(extended, extender); end

  def self.on_module_included(included, includer); end

  def self.pre_cache_module_methods(); end

  def self.register_delegate_class(klass, delegate); end

  def self.start(); end

  def self.trace(); end

  def self.trace_results(); end
end

module Sorbet::Private::GemGeneratorTracepoint
  def self.main(output_dir=T.unsafe(nil)); end

  def self.output_file(); end
end

class Sorbet::Private::GemLoader
  GEM_LOADER = ::T.let(nil, ::T.untyped)
  NO_GEM = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemLoader
  def self.my_require(gem); end

  def self.require_all_gems(); end

  def self.require_gem(gem); end
end

class Sorbet::Private::HiddenMethodFinder
  include ::Sorbet::Private::StepInterface
  def all_modules_and_aliases(); end

  def capture_stderr(); end

  def constant_cache(); end

  def gen_source_rbi(classes, aliases); end

  def looks_like_stub_name(name); end

  def main(); end

  def mk_dir(); end

  def read_constants(); end

  def real_name(mod); end

  def require_everything(); end

  def rm_dir(); end

  def serialize_alias(source_entry, rbi_entry, my_klass, source_symbols, rbi_symbols); end

  def serialize_class(source_entry, rbi_entry, klass, source_symbols, rbi_symbols, source_by_name); end

  def serialize_constants(source, rbi, klass, is_singleton, source_symbols, rbi_symbols); end

  def symbols_id_to_name(entry, prefix); end

  def write_constants(); end

  def write_diff(source, rbi); end
  BLACKLIST = ::T.let(nil, ::T.untyped)
  DIFF_RBI = ::T.let(nil, ::T.untyped)
  ERRORS_RBI = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  HIDDEN_RBI = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  RBI_CONSTANTS = ::T.let(nil, ::T.untyped)
  RBI_CONSTANTS_ERR = ::T.let(nil, ::T.untyped)
  SOURCE_CONSTANTS = ::T.let(nil, ::T.untyped)
  SOURCE_CONSTANTS_ERR = ::T.let(nil, ::T.untyped)
  TMP_PATH = ::T.let(nil, ::T.untyped)
  TMP_RBI = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::HiddenMethodFinder
  def self.main(); end

  def self.output_file(); end
end

module Sorbet::Private::Main
end

module Sorbet::Private::Main
  def self.cyan(msg); end

  def self.emojify(emoji, msg); end

  def self.init(); end

  def self.main(argv); end

  def self.make_step(step); end

  def self.usage(); end

  def self.yellow(msg); end
end

module Sorbet::Private::RealStdlib
end

module Sorbet::Private::RealStdlib
  def self.real_ancestors(mod); end

  def self.real_autoload?(o, klass); end

  def self.real_const_get(obj, const, arg); end

  def self.real_constants(mod); end

  def self.real_eqeq(obj, other); end

  def self.real_hash(o); end

  def self.real_instance_methods(mod, arg); end

  def self.real_is_a?(o, klass); end

  def self.real_method(obj, sym); end

  def self.real_name(o); end

  def self.real_object_id(o); end

  def self.real_private_instance_methods(mod, arg); end

  def self.real_singleton_class(obj); end

  def self.real_singleton_methods(mod, arg); end

  def self.real_spaceship(obj, arg); end

  def self.real_superclass(o); end
end

class Sorbet::Private::RequireEverything
end

class Sorbet::Private::RequireEverything
  def self.excluded_rails_files(); end

  def self.load_bundler(); end

  def self.load_rails(); end

  def self.my_require(abs_path, numerator, denominator); end

  def self.patch_kernel(); end

  def self.rails?(); end

  def self.rails_load_paths(); end

  def self.rb_file_paths(); end

  def self.require_all_files(); end

  def self.require_everything(); end
end

class Sorbet::Private::Serialize
  def alias(base, other_name); end

  def ancestor_has_method(method, klass); end

  def blacklisted_method(method); end

  def class_or_module(class_name); end

  def comparable?(value); end

  def constant(const, value); end

  def from_method(method); end

  def initialize(constant_cache); end

  def serialize_method(method, static=T.unsafe(nil), with_sig: T.unsafe(nil)); end

  def serialize_sig(parameters); end

  def to_sig(kind, name); end

  def valid_class_name(name); end

  def valid_method_name(name); end
  BLACKLIST_CONSTANTS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::Serialize
  def self.header(typed=T.unsafe(nil), subcommand=T.unsafe(nil)); end
end

module Sorbet::Private::Status
end

module Sorbet::Private::Status
  def self.done(); end

  def self.say(message, print_without_tty: T.unsafe(nil)); end
end

module Sorbet::Private::StepInterface
end

module Sorbet::Private::StepInterface
  def self.main(); end

  def self.output_file(); end
end

class Sorbet::Private::SuggestTyped
  include ::Sorbet::Private::StepInterface
end

class Sorbet::Private::SuggestTyped
  def self.main(); end

  def self.output_file(); end

  def self.suggest_typed(); end
end

class Sorbet::Private::TodoRBI
  include ::Sorbet::Private::StepInterface
  HEADER = ::T.let(nil, ::T.untyped)
  OUTPUT = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::TodoRBI
  def self.main(); end

  def self.output_file(); end
end

class SorbetRails::ActiveRecordTEnum::TEnumConfig
  def self.inherited(s); end
end

module SorbetRails::ActiveRecordTEnum
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class SorbetRails::Config
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module SorbetRails::CustomParamsMethods
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class SorbetRails::HelperRbiFormatter
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class SorbetRails::MailerRbiFormatter
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module SorbetRails::ModelPlugins
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class SorbetRails::ModelRbiFormatter
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module SorbetRails::ModelUtils
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module SorbetRails::PluckToTStruct
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class SorbetRails::RoutesRbiFormatter
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module SorbetRails::SorbetUtils
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module SorbetRails::Utils
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module SorbetRails
  extend ::T::Private::Methods::SingletonMethodHooks
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

class StopIteration
  def result(); end
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def []=(*_); end

  def casecmp?(_); end

  def each_grapheme_cluster(); end

  def encode!(*_); end

  def grapheme_clusters(); end

  def reverse!(); end

  def shellescape(); end

  def shellsplit(); end

  def succ!(); end

  def to_d(); end

  def undump(); end

  def unicode_normalize(*_); end

  def unicode_normalize!(*_); end

  def unicode_normalized?(*_); end

  def unpack1(_); end
  BLANK_RE = ::T.let(nil, ::T.untyped)
  ENCODED_BLANKS = ::T.let(nil, ::T.untyped)
end

class StringIO
  def length(); end

  def truncate(_); end
end

class StringScanner
  def <<(_); end

  def [](_); end

  def beginning_of_line?(); end

  def bol?(); end

  def captures(); end

  def charpos(); end

  def check(_); end

  def check_until(_); end

  def clear(); end

  def concat(_); end

  def empty?(); end

  def exist?(_); end

  def get_byte(); end

  def getbyte(); end

  def initialize(*_); end

  def match?(_); end

  def matched(); end

  def matched?(); end

  def matched_size(); end

  def peek(_); end

  def peep(_); end

  def pointer(); end

  def pointer=(pointer); end

  def pos(); end

  def pos=(pos); end

  def post_match(); end

  def pre_match(); end

  def reset(); end

  def rest(); end

  def rest?(); end

  def rest_size(); end

  def restsize(); end

  def scan_full(_, _1, _2); end

  def scan_until(_); end

  def search_full(_, _1, _2); end

  def size(); end

  def skip(_); end

  def skip_until(_); end

  def string(); end

  def string=(string); end

  def terminate(); end

  def unscan(); end

  def values_at(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class StringScanner
  def self.must_C_version(); end
end

class Struct
  def [](_); end

  def []=(_, _1); end

  def dig(*_); end

  def each_pair(); end

  def length(); end

  def members(); end

  def select(*_); end

  def size(); end

  def to_a(); end

  def to_h(); end

  def values(); end

  def values_at(*_); end
end

Struct::Group = Etc::Group

class Struct::HTMLElementDescription
  def attrs_depr(); end

  def attrs_depr=(_); end

  def attrs_opt(); end

  def attrs_opt=(_); end

  def attrs_req(); end

  def attrs_req=(_); end

  def defaultsubelt(); end

  def defaultsubelt=(_); end

  def depr(); end

  def depr=(_); end

  def desc(); end

  def desc=(_); end

  def dtd(); end

  def dtd=(_); end

  def empty(); end

  def empty=(_); end

  def endTag(); end

  def endTag=(_); end

  def isinline(); end

  def isinline=(_); end

  def name(); end

  def name=(_); end

  def saveEndTag(); end

  def saveEndTag=(_); end

  def startTag(); end

  def startTag=(_); end

  def subelts(); end

  def subelts=(_); end
end

class Struct::HTMLElementDescription
  def self.[](*_); end

  def self.members(); end
end

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class SynchronizedDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class SystemCallError
  def errno(); end
end

class SystemExit
  def status(); end

  def success?(); end
end

class TA
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module TZInfo::RubyCoreSupport
  HALF_DAYS_IN_DAY = ::T.let(nil, ::T.untyped)
end

class TZInfo::ZoneinfoDataSource
  DEFAULT_ALTERNATE_ISO3166_TAB_SEARCH_PATH = ::T.let(nil, ::T.untyped)
  DEFAULT_SEARCH_PATH = ::T.let(nil, ::T.untyped)
end

class TZInfo::ZoneinfoTimezoneInfo
  MAX_TIMESTAMP = ::T.let(nil, ::T.untyped)
  MIN_TIMESTAMP = ::T.let(nil, ::T.untyped)
end

module ThreadSafe
  NULL = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

ThreadSafe::Array = Array

class ThreadSafe::AtomicReferenceCacheBackend
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def compute(key); end

  def compute_if_absent(key); end

  def compute_if_present(key); end

  def delete(key); end

  def delete_pair(key, value); end

  def each_pair(); end

  def empty?(); end

  def get_and_set(key, value); end

  def get_or_default(key, else_value=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def key?(key); end

  def merge_pair(key, value); end

  def replace_if_exists(key, new_value); end

  def replace_pair(key, old_value, new_value); end

  def size(); end
  DEFAULT_CAPACITY = ::T.let(nil, ::T.untyped)
  HASH_BITS = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MAX_CAPACITY = ::T.let(nil, ::T.untyped)
  MOVED = ::T.let(nil, ::T.untyped)
  NOW_RESIZING = ::T.let(nil, ::T.untyped)
  TRANSFER_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  WAITING = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::AtomicReferenceCacheBackend::Node
  include ::ThreadSafe::Util::CheapLockable
  def initialize(hash, key, value, next_node=T.unsafe(nil)); end

  def key(); end

  def key?(key); end

  def locked?(); end

  def matches?(key, hash); end

  def pure_hash(); end

  def try_await_lock(table, i); end

  def try_lock_via_hash(node_hash=T.unsafe(nil)); end

  def unlock_via_hash(locked_hash, node_hash); end
  HASH_BITS = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MOVED = ::T.let(nil, ::T.untyped)
  SPIN_LOCK_ATTEMPTS = ::T.let(nil, ::T.untyped)
  WAITING = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::AtomicReferenceCacheBackend::Node
  extend ::ThreadSafe::Util::Volatile
  def self.locked_hash?(hash); end
end

class ThreadSafe::AtomicReferenceCacheBackend::Table
  def cas_new_node(i, hash, key, value); end

  def delete_node_at(i, node, predecessor_node); end

  def try_lock_via_hash(i, node, node_hash); end

  def try_to_cas_in_computed(i, hash, key); end
end

class ThreadSafe::AtomicReferenceCacheBackend::Table
end

class ThreadSafe::AtomicReferenceCacheBackend
  extend ::ThreadSafe::Util::Volatile
end

ThreadSafe::ConcurrentCacheBackend = ThreadSafe::MriCacheBackend

ThreadSafe::Hash = Hash

class ThreadSafe::MriCacheBackend
  WRITE_LOCK = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::SynchronizedCacheBackend
  include ::Mutex_m
  def lock(); end

  def locked?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class ThreadSafe::SynchronizedCacheBackend
end

module ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::Util::Adder
  def add(x); end

  def decrement(); end

  def increment(); end

  def reset(); end

  def sum(); end
end

class ThreadSafe::Util::Adder
end

class ThreadSafe::Util::AtomicReference
  def compare_and_set(old_value, new_value); end

  def get(); end

  def initialize(value=T.unsafe(nil)); end

  def set(new_value); end

  def value(); end

  def value=(new_value); end
end

class ThreadSafe::Util::AtomicReference
end

module ThreadSafe::Util::CheapLockable
  def cas_mutex(old_value, new_value); end

  def compare_and_set_mutex(old_value, new_value); end

  def lazy_set_mutex(value); end

  def mutex(); end

  def mutex=(value); end
end

module ThreadSafe::Util::CheapLockable
  extend ::ThreadSafe::Util::Volatile
end

class ThreadSafe::Util::PowerOfTwoTuple
  def hash_to_index(hash); end

  def next_in_size_table(); end

  def volatile_get_by_hash(hash); end

  def volatile_set_by_hash(hash, value); end
end

class ThreadSafe::Util::PowerOfTwoTuple
end

class ThreadSafe::Util::Striped64
  def busy?(); end

  def initialize(); end

  def retry_update(x, hash_code, was_uncontended); end
  THREAD_LOCAL_KEY = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::Util::Striped64::Cell
  def cas(old_value, new_value); end

  def cas_computed(); end

  def padding_(); end
end

class ThreadSafe::Util::Striped64::Cell
end

class ThreadSafe::Util::Striped64
  extend ::ThreadSafe::Util::Volatile
end

module ThreadSafe::Util::Volatile
  def attr_volatile(*attr_names); end
end

module ThreadSafe::Util::Volatile
end

class ThreadSafe::Util::VolatileTuple
  include ::Enumerable
  def cas(i, old_value, new_value); end

  def compare_and_set(i, old_value, new_value); end

  def each(&blk); end

  def initialize(size); end

  def size(); end

  def volatile_get(i); end

  def volatile_set(i, value); end
end

class ThreadSafe::Util::VolatileTuple
end

module ThreadSafe::Util::XorShiftRandom
  def get(); end

  def xorshift(x); end
  MAX_XOR_SHIFTABLE_INT = ::T.let(nil, ::T.untyped)
end

module ThreadSafe::Util::XorShiftRandom
  extend ::ThreadSafe::Util::XorShiftRandom
end

module ThreadSafe::Util
end

class Time
  COMMON_YEAR_DAYS_IN_MONTH = ::T.let(nil, ::T.untyped)
  DATE_FORMATS = ::T.let(nil, ::T.untyped)
end

class TracePoint
  def event(); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

module URI
  include ::URI::RFC2396_REGEXP
end

module URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

class URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.get_encoding(label); end

  def self.parser(); end

end

class UnboundMethod
  def clone(); end

  def original_name(); end
end

class UncaughtThrowError
  def tag(); end

  def value(); end
end

module UnicodeNormalize
end

module UnicodeNormalize
end

Visitor = Psych::Visitors::Visitor

module Warning
  def warn(_); end
end

module Warning
  extend ::Warning
end

YAML = Psych

YAMLTree = Psych::Visitors::YAMLTree
