# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/sqlite3/all/sqlite3.rbi
#
# sqlite3-1.4.2

class SQLite3::Database
  def authorizer(&block); end
  def authorizer=(arg0); end
  def busy_handler(*arg0); end
  def busy_timeout(arg0); end
  def busy_timeout=(arg0); end
  def changes; end
  def close; end
  def closed?; end
  def collation(arg0, arg1); end
  def collations; end
  def commit; end
  def complete?(arg0); end
  def create_aggregate(name, arity, step = nil, finalize = nil, text_rep = nil, &block); end
  def create_aggregate_handler(handler); end
  def create_function(name, arity, text_rep = nil, &block); end
  def db_filename(arg0); end
  def define_aggregator(name, aggregator); end
  def define_aggregator2(arg0, arg1); end
  def define_function(arg0); end
  def define_function_with_flags(arg0, arg1); end
  def enable_load_extension(arg0); end
  def encoding; end
  def errcode; end
  def errmsg; end
  def exec_batch(arg0, arg1); end
  def execute(sql, bind_vars = nil, *args, &block); end
  def execute2(sql, *bind_vars); end
  def execute_batch(sql, bind_vars = nil, *args); end
  def execute_batch2(sql, &block); end
  def extended_result_codes=(arg0); end
  def filename(db_name = nil); end
  def get_first_row(sql, *bind_vars); end
  def get_first_value(sql, *bind_vars); end
  def initialize(file, options = nil, zvfs = nil); end
  def interrupt; end
  def last_insert_row_id; end
  def load_extension(arg0); end
  def make_type_translator(should_translate); end
  def open16(arg0); end
  def open_v2(arg0, arg1, arg2); end
  def prepare(sql); end
  def query(sql, bind_vars = nil, *args); end
  def readonly?; end
  def results_as_hash; end
  def results_as_hash=(arg0); end
  def rollback; end
  def self.open(*arg0); end
  def self.quote(string); end
  def total_changes; end
  def trace(*arg0); end
  def transaction(mode = nil); end
  def transaction_active?; end
  def translate_from_db(types, row); end
  def translator; end
  def type_translation; end
  def type_translation=(value); end
  include SQLite3::Pragmas
end
class SQLite3::Statement
  def active?; end
  def bind_param(arg0, arg1); end
  def bind_parameter_count; end
  def bind_params(*bind_vars); end
  def clear_bindings!; end
  def close; end
  def closed?; end
  def column_count; end
  def column_decltype(arg0); end
  def column_name(arg0); end
  def columns; end
  def database_name(arg0); end
  def done?; end
  def each; end
  def execute!(*bind_vars, &block); end
  def execute(*bind_vars); end
  def get_metadata; end
  def initialize(arg0, arg1); end
  def must_be_open!; end
  def remainder; end
  def reset!; end
  def step; end
  def types; end
  include Enumerable
end
class SQLite3::Backup
  def finish; end
  def initialize(arg0, arg1, arg2, arg3); end
  def pagecount; end
  def remaining; end
  def step(arg0); end
end
module SQLite3
  def self.const_missing(name); end
  def self.libversion; end
  def self.sqlcipher?; end
  def self.threadsafe; end
  def self.threadsafe?; end
end
module SQLite3::Constants
end
module SQLite3::Constants::TextRep
end
module SQLite3::Constants::ColumnType
end
module SQLite3::Constants::ErrorCode
end
class SQLite3::Exception < StandardError
  def code; end
end
class SQLite3::SQLException < SQLite3::Exception
end
class SQLite3::InternalException < SQLite3::Exception
end
class SQLite3::PermissionException < SQLite3::Exception
end
class SQLite3::AbortException < SQLite3::Exception
end
class SQLite3::BusyException < SQLite3::Exception
end
class SQLite3::LockedException < SQLite3::Exception
end
class SQLite3::MemoryException < SQLite3::Exception
end
class SQLite3::ReadOnlyException < SQLite3::Exception
end
class SQLite3::InterruptException < SQLite3::Exception
end
class SQLite3::IOException < SQLite3::Exception
end
class SQLite3::CorruptException < SQLite3::Exception
end
class SQLite3::NotFoundException < SQLite3::Exception
end
class SQLite3::FullException < SQLite3::Exception
end
class SQLite3::CantOpenException < SQLite3::Exception
end
class SQLite3::ProtocolException < SQLite3::Exception
end
class SQLite3::EmptyException < SQLite3::Exception
end
class SQLite3::SchemaChangedException < SQLite3::Exception
end
class SQLite3::TooBigException < SQLite3::Exception
end
class SQLite3::ConstraintException < SQLite3::Exception
end
class SQLite3::MismatchException < SQLite3::Exception
end
class SQLite3::MisuseException < SQLite3::Exception
end
class SQLite3::UnsupportedException < SQLite3::Exception
end
class SQLite3::AuthorizationException < SQLite3::Exception
end
class SQLite3::FormatException < SQLite3::Exception
end
class SQLite3::RangeException < SQLite3::Exception
end
class SQLite3::NotADatabaseException < SQLite3::Exception
end
module SQLite3::Pragmas
  def application_id; end
  def application_id=(integer); end
  def auto_vacuum; end
  def auto_vacuum=(mode); end
  def automatic_index; end
  def automatic_index=(mode); end
  def busy_timeout; end
  def busy_timeout=(milliseconds); end
  def cache_size; end
  def cache_size=(size); end
  def cache_spill; end
  def cache_spill=(mode); end
  def case_sensitive_like=(mode); end
  def cell_size_check; end
  def cell_size_check=(mode); end
  def checkpoint_fullfsync; end
  def checkpoint_fullfsync=(mode); end
  def collation_list(&block); end
  def compile_options(&block); end
  def count_changes; end
  def count_changes=(mode); end
  def data_version; end
  def database_list(&block); end
  def default_cache_size; end
  def default_cache_size=(size); end
  def default_synchronous; end
  def default_synchronous=(mode); end
  def default_temp_store; end
  def default_temp_store=(mode); end
  def defer_foreign_keys; end
  def defer_foreign_keys=(mode); end
  def encoding; end
  def encoding=(mode); end
  def foreign_key_check(*table, &block); end
  def foreign_key_list(table, &block); end
  def foreign_keys; end
  def foreign_keys=(mode); end
  def freelist_count; end
  def full_column_names; end
  def full_column_names=(mode); end
  def fullfsync; end
  def fullfsync=(mode); end
  def get_boolean_pragma(name); end
  def get_enum_pragma(name); end
  def get_int_pragma(name); end
  def get_query_pragma(name, *parms, &block); end
  def ignore_check_constraints=(mode); end
  def incremental_vacuum(pages, &block); end
  def index_info(index, &block); end
  def index_list(table, &block); end
  def index_xinfo(index, &block); end
  def integrity_check(*num_errors, &block); end
  def journal_mode; end
  def journal_mode=(mode); end
  def journal_size_limit; end
  def journal_size_limit=(size); end
  def legacy_file_format; end
  def legacy_file_format=(mode); end
  def locking_mode; end
  def locking_mode=(mode); end
  def max_page_count; end
  def max_page_count=(size); end
  def mmap_size; end
  def mmap_size=(size); end
  def page_count; end
  def page_size; end
  def page_size=(size); end
  def parser_trace=(mode); end
  def query_only; end
  def query_only=(mode); end
  def quick_check(*num_errors, &block); end
  def read_uncommitted; end
  def read_uncommitted=(mode); end
  def recursive_triggers; end
  def recursive_triggers=(mode); end
  def reverse_unordered_selects; end
  def reverse_unordered_selects=(mode); end
  def schema_cookie; end
  def schema_cookie=(cookie); end
  def schema_version; end
  def schema_version=(version); end
  def secure_delete; end
  def secure_delete=(mode); end
  def set_boolean_pragma(name, mode); end
  def set_enum_pragma(name, mode, enums); end
  def set_int_pragma(name, value); end
  def short_column_names; end
  def short_column_names=(mode); end
  def shrink_memory; end
  def soft_heap_limit; end
  def soft_heap_limit=(mode); end
  def stats(&block); end
  def synchronous; end
  def synchronous=(mode); end
  def table_info(table); end
  def temp_store; end
  def temp_store=(mode); end
  def threads; end
  def threads=(count); end
  def tweak_default(hash); end
  def user_cookie; end
  def user_cookie=(cookie); end
  def user_version; end
  def user_version=(version); end
  def vdbe_addoptrace=(mode); end
  def vdbe_debug=(mode); end
  def vdbe_listing=(mode); end
  def vdbe_trace; end
  def vdbe_trace=(mode); end
  def version_compare(v1, v2); end
  def wal_autocheckpoint; end
  def wal_autocheckpoint=(mode); end
  def wal_checkpoint; end
  def wal_checkpoint=(mode); end
  def writable_schema=(mode); end
end
class SQLite3::ResultSet
  def close; end
  def closed?; end
  def columns; end
  def each; end
  def each_hash; end
  def eof?; end
  def initialize(db, stmt); end
  def next; end
  def next_hash; end
  def reset(*bind_params); end
  def types; end
  include Enumerable
end
class SQLite3::ResultSet::ArrayWithTypes < Array
  def types; end
  def types=(arg0); end
end
class SQLite3::ResultSet::ArrayWithTypesAndFields < Array
  def fields; end
  def fields=(arg0); end
  def types; end
  def types=(arg0); end
end
class SQLite3::ResultSet::HashWithTypesAndFields < Hash
  def [](key); end
  def fields; end
  def fields=(arg0); end
  def types; end
  def types=(arg0); end
end
class String
  def to_blob; end
end
class SQLite3::Translator
  def add_translator(type, &block); end
  def initialize; end
  def register_default_translators; end
  def translate(type, value); end
  def type_name(type); end
end
class SQLite3::Value
  def handle; end
  def initialize(db, handle); end
  def length(utf16 = nil); end
  def null?; end
  def to_blob; end
  def to_f; end
  def to_i; end
  def to_int64; end
  def to_s(utf16 = nil); end
  def type; end
end
class SQLite3::Database::FunctionProxy
  def [](key); end
  def []=(key, value); end
  def count; end
  def initialize; end
  def result; end
  def result=(arg0); end
  def set_error(error); end
end
module SQLite3::VersionProxy
end
