# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/activemodel/all/activemodel.rbi
#
# activemodel-4.2.11
module ActiveModel
  def self.eager_load!; end
  def self.gem_version; end
  def self.version; end
  extend ActiveSupport::Autoload
end
module ActiveModel::VERSION
end
module ActiveModel::Serializers
  extend ActiveSupport::Autoload
end
class ActiveModel::Railtie < Rails::Railtie
end
class ActiveModel::MissingAttributeError < NoMethodError
end
module ActiveModel::AttributeMethods
  def attribute_method?(attr_name); end
  def attribute_missing(match, *args, &block); end
  def match_attribute_method?(method_name); end
  def method_missing(method, *args, &block); end
  def missing_attribute(attr_name, stack); end
  def respond_to?(method, include_private_methods = nil); end
  def respond_to_without_attributes?(*arg0); end
  extend ActiveSupport::Concern
end
module ActiveModel::AttributeMethods::ClassMethods
  def alias_attribute(new_name, old_name); end
  def attribute_alias(name); end
  def attribute_alias?(new_name); end
  def attribute_method_affix(*affixes); end
  def attribute_method_matchers_cache; end
  def attribute_method_matchers_matching(method_name); end
  def attribute_method_prefix(*prefixes); end
  def attribute_method_suffix(*suffixes); end
  def define_attribute_method(attr_name); end
  def define_attribute_methods(*attr_names); end
  def define_proxy_call(include_private, mod, name, send, *extra); end
  def generated_attribute_methods; end
  def instance_method_already_implemented?(method_name); end
  def undefine_attribute_methods; end
end
class ActiveModel::AttributeMethods::ClassMethods::AttributeMethodMatcher
  def initialize(options = nil); end
  def match(method_name); end
  def method_missing_target; end
  def method_name(attr_name); end
  def plain?; end
  def prefix; end
  def suffix; end
end
class ActiveModel::AttributeMethods::ClassMethods::AttributeMethodMatcher::AttributeMethodMatch < Struct
  def attr_name; end
  def attr_name=(_); end
  def method_name; end
  def method_name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def target; end
  def target=(_); end
end
module ActiveModel::SecurePassword
  def self.min_cost; end
  def self.min_cost=(arg0); end
  extend ActiveSupport::Concern
end
module ActiveModel::SecurePassword::ClassMethods
  def has_secure_password(options = nil); end
end
module ActiveModel::SecurePassword::InstanceMethodsOnActivation
  def authenticate(unencrypted_password); end
  def password; end
  def password=(unencrypted_password); end
  def password_confirmation=(unencrypted_password); end
end
class ActiveModel::Name
  def !~(*args, &block); end
  def <=>(*args, &block); end
  def ==(arg); end
  def ===(arg); end
  def =~(*args, &block); end
  def _singularize(string, replacement = nil); end
  def as_json(*args, &block); end
  def cache_key; end
  def collection; end
  def element; end
  def eql?(*args, &block); end
  def human(options = nil); end
  def i18n_key; end
  def initialize(klass, namespace = nil, name = nil); end
  def name; end
  def param_key; end
  def plural; end
  def route_key; end
  def singular; end
  def singular_route_key; end
  def to_s(*args, &block); end
  def to_str(*args, &block); end
  include Comparable
end
module ActiveModel::Naming
  def model_name; end
  def self.extended(base); end
  def self.model_name_from_record_or_class(record_or_class); end
  def self.param_key(record_or_class); end
  def self.plural(record_or_class); end
  def self.route_key(record_or_class); end
  def self.singular(record_or_class); end
  def self.singular_route_key(record_or_class); end
  def self.uncountable?(record_or_class); end
end
module ActiveModel::Translation
  def human_attribute_name(attribute, options = nil); end
  def i18n_scope; end
  def lookup_ancestors; end
  include ActiveModel::Naming
end
class ActiveModel::ForbiddenAttributesError < StandardError
end
module ActiveModel::ForbiddenAttributesProtection
  def sanitize_for_mass_assignment(attributes); end
  def sanitize_forbidden_attributes(attributes); end
end
module ActiveModel::Conversion
  def to_key; end
  def to_model; end
  def to_param; end
  def to_partial_path; end
  extend ActiveSupport::Concern
end
module ActiveModel::Conversion::ClassMethods
  def _to_partial_path; end
end
module ActiveModel::Validations
  def errors; end
  def initialize_dup(other); end
  def invalid?(context = nil); end
  def read_attribute_for_validation(*arg0); end
  def run_validations!; end
  def valid?(context = nil); end
  def validate(context = nil); end
  def validates_with(*args, &block); end
  extend ActiveSupport::Concern
end
module ActiveModel::Validations::Callbacks
  def run_validations!; end
  extend ActiveSupport::Concern
end
module ActiveModel::Validations::Callbacks::ClassMethods
  def after_validation(*args, &block); end
  def before_validation(*args, &block); end
end
module ActiveModel::Validations::Clusivity
  def check_validity!; end
  def delimiter; end
  def include?(record, value); end
  def inclusion_method(enumerable); end
end
class ActiveModel::Validator
  def initialize(options = nil); end
  def kind; end
  def options; end
  def self.kind; end
  def validate(record); end
end
class ActiveModel::EachValidator < ActiveModel::Validator
  def attributes; end
  def check_validity!; end
  def initialize(options); end
  def validate(record); end
  def validate_each(record, attribute, value); end
end
class ActiveModel::BlockValidator < ActiveModel::EachValidator
  def initialize(options, &block); end
  def validate_each(record, attribute, value); end
end
class ActiveModel::Validations::ExclusionValidator < ActiveModel::EachValidator
  def validate_each(record, attribute, value); end
  include ActiveModel::Validations::Clusivity
end
module ActiveModel::Validations::HelperMethods
  def _merge_attributes(attr_names); end
  def validates_absence_of(*attr_names); end
  def validates_acceptance_of(*attr_names); end
  def validates_confirmation_of(*attr_names); end
  def validates_exclusion_of(*attr_names); end
  def validates_format_of(*attr_names); end
  def validates_inclusion_of(*attr_names); end
  def validates_length_of(*attr_names); end
  def validates_numericality_of(*attr_names); end
  def validates_presence_of(*attr_names); end
  def validates_size_of(*attr_names); end
end
class ActiveModel::Validations::AcceptanceValidator < ActiveModel::EachValidator
  def initialize(options); end
  def setup!(klass); end
  def validate_each(record, attribute, value); end
end
class ActiveModel::Validations::WithValidator < ActiveModel::EachValidator
  def validate_each(record, attr, val); end
end
module ActiveModel::Validations::ClassMethods
  def _parse_validates_options(options); end
  def _validates_default_keys; end
  def attribute_method?(attribute); end
  def clear_validators!; end
  def inherited(base); end
  def validate(*args, &block); end
  def validates!(*attributes); end
  def validates(*attributes); end
  def validates_each(*attr_names, &block); end
  def validates_with(*args, &block); end
  def validators; end
  def validators_on(*attributes); end
end
class ActiveModel::Validations::LengthValidator < ActiveModel::EachValidator
  def check_validity!; end
  def initialize(options); end
  def skip_nil_check?(key); end
  def tokenize(value); end
  def validate_each(record, attribute, value); end
end
class ActiveModel::Validations::ConfirmationValidator < ActiveModel::EachValidator
  def initialize(options); end
  def setup!(klass); end
  def validate_each(record, attribute, value); end
end
class ActiveModel::Validations::AbsenceValidator < ActiveModel::EachValidator
  def validate_each(record, attr_name, value); end
end
class ActiveModel::Validations::InclusionValidator < ActiveModel::EachValidator
  def validate_each(record, attribute, value); end
  include ActiveModel::Validations::Clusivity
end
class ActiveModel::Validations::FormatValidator < ActiveModel::EachValidator
  def check_options_validity(name); end
  def check_validity!; end
  def option_call(record, name); end
  def record_error(record, attribute, name, value); end
  def regexp_using_multiline_anchors?(regexp); end
  def validate_each(record, attribute, value); end
end
class ActiveModel::Validations::PresenceValidator < ActiveModel::EachValidator
  def validate_each(record, attr_name, value); end
end
class ActiveModel::Validations::NumericalityValidator < ActiveModel::EachValidator
  def allow_only_integer?(record); end
  def check_validity!; end
  def filtered_options(value); end
  def parse_raw_value_as_a_number(raw_value); end
  def parse_raw_value_as_an_integer(raw_value); end
  def record_attribute_changed_in_place?(record, attr_name); end
  def validate_each(record, attr_name, value); end
end
module ActiveModel::Callbacks
  def _define_after_model_callback(klass, callback); end
  def _define_around_model_callback(klass, callback); end
  def _define_before_model_callback(klass, callback); end
  def define_model_callbacks(*callbacks); end
  def self.extended(base); end
end
module ActiveModel::Dirty
  def attribute_change(attr); end
  def attribute_changed?(attr, options = nil); end
  def attribute_changed_by_setter?(attr_name); end
  def attribute_was(attr); end
  def attribute_will_change!(attr); end
  def attributes_changed_by_setter; end
  def changed; end
  def changed?; end
  def changed_attributes; end
  def changes; end
  def changes_applied; end
  def changes_include?(attr_name); end
  def clear_attribute_changes(attributes); end
  def clear_changes_information; end
  def previous_changes; end
  def reset_attribute!(attr); end
  def reset_changes; end
  def restore_attribute!(attr); end
  def restore_attributes(attributes = nil); end
  def set_attribute_was(attr, old_value); end
  extend ActiveSupport::Concern
  include ActiveModel::AttributeMethods
end
module ActiveModel::Serialization
  def read_attribute_for_serialization(*arg0); end
  def serializable_add_includes(options = nil); end
  def serializable_hash(options = nil); end
end
module ActiveModel::Serializers::JSON
  def as_json(options = nil); end
  def from_json(json, include_root = nil); end
  extend ActiveSupport::Concern
  include ActiveModel::Serialization
end
module ActiveModel::Serializers::Xml
  def from_xml(xml); end
  def to_xml(options = nil, &block); end
  extend ActiveSupport::Concern
  include ActiveModel::Serialization
end
class ActiveModel::Serializers::Xml::Serializer
  def add_associations(association, records, opts); end
  def add_attributes_and_methods; end
  def add_extra_behavior; end
  def add_includes; end
  def add_procs; end
  def initialize(serializable, options = nil); end
  def options; end
  def serializable_collection; end
  def serializable_hash; end
  def serialize; end
end
class ActiveModel::Serializers::Xml::Serializer::Attribute
  def compute_type; end
  def decorations; end
  def initialize(name, serializable, value); end
  def name; end
  def type; end
  def value; end
end
class ActiveModel::Serializers::Xml::Serializer::MethodAttribute < ActiveModel::Serializers::Xml::Serializer::Attribute
end
