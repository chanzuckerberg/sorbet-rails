# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strong
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/concurrent-ruby/all/concurrent-ruby.rbi
#
# concurrent-ruby-1.1.5
module Concurrent
  extend Concurrent::Utility::EngineDetector
  extend Concurrent::Utility::NativeExtensionLoader
end
module Concurrent::Utility
end
module Concurrent::Utility::EngineDetector
  def on_cruby?; end
  def on_jruby?; end
  def on_jruby_9000?; end
  def on_linux?; end
  def on_osx?; end
  def on_rbx?; end
  def on_truffleruby?; end
  def on_windows?; end
  def ruby_engine; end
  def ruby_version(version = nil, comparison, major, minor, patch); end
end
module Concurrent::Synchronization
end
class Concurrent::Synchronization::AbstractObject
  def full_memory_barrier; end
  def initialize; end
  def self.attr_volatile(*names); end
end
module Concurrent::Utility::NativeExtensionLoader
  def allow_c_extensions?; end
  def c_extensions_loaded?; end
  def java_extensions_loaded?; end
  def load_error_path(error); end
  def load_native_extensions; end
  def set_c_extensions_loaded; end
  def set_java_extensions_loaded; end
  def try_load_c_extension(path); end
end
module Concurrent::Synchronization::MriAttrVolatile
  def full_memory_barrier; end
  def self.included(base); end
end
module Concurrent::Synchronization::MriAttrVolatile::ClassMethods
  def attr_volatile(*names); end
end
class Concurrent::Synchronization::MriObject < Concurrent::Synchronization::AbstractObject
  def initialize; end
  extend Concurrent::Synchronization::MriAttrVolatile::ClassMethods
  include Concurrent::Synchronization::MriAttrVolatile
end
module Concurrent::Synchronization::RbxAttrVolatile
  def full_memory_barrier; end
  def self.included(base); end
end
module Concurrent::Synchronization::RbxAttrVolatile::ClassMethods
  def attr_volatile(*names); end
end
class Concurrent::Synchronization::RbxObject < Concurrent::Synchronization::AbstractObject
  def initialize; end
  extend Concurrent::Synchronization::RbxAttrVolatile::ClassMethods
  include Concurrent::Synchronization::RbxAttrVolatile
end
module Concurrent::Synchronization::TruffleRubyAttrVolatile
  def full_memory_barrier; end
  def self.included(base); end
end
module Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods
  def attr_volatile(*names); end
end
class Concurrent::Synchronization::TruffleRubyObject < Concurrent::Synchronization::AbstractObject
  def initialize; end
  extend Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods
  include Concurrent::Synchronization::TruffleRubyAttrVolatile
end
class Concurrent::Synchronization::Object < Concurrent::Synchronization::MriObject
  def __initialize_atomic_fields__; end
  def initialize; end
  def self.atomic_attribute?(name); end
  def self.atomic_attributes(inherited = nil); end
  def self.attr_atomic(*names); end
  def self.define_initialize_atomic_fields; end
  def self.ensure_safe_initialization_when_final_fields_are_present; end
  def self.safe_initialization!; end
  def self.safe_initialization?; end
end
class Concurrent::Synchronization::AbstractLockableObject < Concurrent::Synchronization::Object
  def ns_broadcast; end
  def ns_signal; end
  def ns_wait(timeout = nil); end
  def ns_wait_until(timeout = nil, &condition); end
  def synchronize; end
end
module Concurrent::Synchronization::ConditionSignalling
  def ns_broadcast; end
  def ns_signal; end
end
class Concurrent::Synchronization::MutexLockableObject < Concurrent::Synchronization::AbstractLockableObject
  def initialize(*defaults); end
  def ns_wait(timeout = nil); end
  def self.new(*args, &block); end
  def synchronize; end
  include Concurrent::Synchronization::ConditionSignalling
end
class Concurrent::Synchronization::MonitorLockableObject < Concurrent::Synchronization::AbstractLockableObject
  def initialize(*defaults); end
  def ns_wait(timeout = nil); end
  def self.new(*args, &block); end
  def synchronize; end
  include Concurrent::Synchronization::ConditionSignalling
end
class Concurrent::Synchronization::RbxLockableObject < Concurrent::Synchronization::AbstractLockableObject
  def initialize(*defaults); end
  def ns_broadcast; end
  def ns_signal; end
  def ns_wait(timeout = nil); end
  def self.new(*args, &block); end
  def synchronize(&block); end
end
class Concurrent::Synchronization::LockableObject < Concurrent::Synchronization::MutexLockableObject
  def new_condition; end
end
class Concurrent::Synchronization::Condition < Concurrent::Synchronization::LockableObject
  def broadcast; end
  def initialize(lock); end
  def ns_broadcast; end
  def ns_signal; end
  def ns_wait(timeout = nil); end
  def ns_wait_until(timeout = nil, &condition); end
  def self.new(*args, &block); end
  def self.private_new(*args, &block); end
  def signal; end
  def wait(timeout = nil); end
  def wait_until(timeout = nil, &condition); end
end
class Concurrent::Synchronization::Lock < Concurrent::Synchronization::LockableObject
  def broadcast; end
  def ns_broadcast; end
  def ns_signal; end
  def ns_wait(timeout = nil); end
  def ns_wait_until(timeout = nil, &condition); end
  def signal; end
  def synchronize; end
  def wait(timeout = nil); end
  def wait_until(timeout = nil, &condition); end
end
module Concurrent::Collection
end
class Concurrent::Collection::NonConcurrentMapBackend
  def [](key); end
  def []=(key, value); end
  def _get(key); end
  def _set(key, value); end
  def clear; end
  def compute(key); end
  def compute_if_absent(key); end
  def compute_if_present(key); end
  def delete(key); end
  def delete_pair(key, value); end
  def dupped_backend; end
  def each_pair; end
  def get_and_set(key, value); end
  def get_or_default(key, default_value); end
  def initialize(options = nil); end
  def initialize_copy(other); end
  def key?(key); end
  def merge_pair(key, value); end
  def pair?(key, expected_value); end
  def replace_if_exists(key, new_value); end
  def replace_pair(key, old_value, new_value); end
  def size; end
  def store_computed_value(key, new_value); end
end
class Concurrent::Collection::MriMapBackend < Concurrent::Collection::NonConcurrentMapBackend
  def []=(key, value); end
  def clear; end
  def compute(key); end
  def compute_if_absent(key); end
  def compute_if_present(key); end
  def delete(key); end
  def delete_pair(key, value); end
  def get_and_set(key, value); end
  def initialize(options = nil); end
  def merge_pair(key, value); end
  def replace_if_exists(key, new_value); end
  def replace_pair(key, old_value, new_value); end
end
class Concurrent::Map < Concurrent::Collection::MriMapBackend
  def [](key); end
  def each; end
  def each_key; end
  def each_pair; end
  def each_value; end
  def empty?; end
  def fetch(key, default_value = nil); end
  def fetch_or_store(key, default_value = nil); end
  def get(key); end
  def initialize(options = nil, &block); end
  def initialize_copy(other); end
  def inspect; end
  def key(value); end
  def keys; end
  def marshal_dump; end
  def marshal_load(hash); end
  def populate_from(hash); end
  def put(key, value); end
  def put_if_absent(key, value); end
  def raise_fetch_no_key; end
  def validate_options_hash!(options); end
  def value?(value); end
  def values; end
end
